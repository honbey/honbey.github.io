<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2024-01-07 Sun 22:10 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nginx</title>
<meta name="author" content="Honbey Zhang" />
<meta name="generator" content="Org Mode" />
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Nginx</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgff43445">Nginx</a>
<ul>
<li><a href="#orgc12cfa0">架构</a></li>
<li><a href="#org5071cb7">请求流程</a></li>
<li><a href="#org021a5f8">connection</a></li>
<li><a href="#orgcd2250f">request</a></li>
<li><a href="#orgd5f2684">pipe</a></li>
<li><a href="#orgb193bec">lingering_close</a></li>
</ul>
</li>
<li><a href="#org226d305">Data Structure</a>
<ul>
<li><a href="#org9b602ed">ngx_str_t</a></li>
<li><a href="#org35864c1">ngx_pool_t</a></li>
<li><a href="#org71fbe09">ngx_array_t</a></li>
<li><a href="#orga35044f">ngx_hash_t</a></li>
<li><a href="#org8582ebf">ngx_chain_t</a></li>
<li><a href="#orga3a75b7">ngx_buf_t</a></li>
<li><a href="#orgd9634fd">ngx_list_t</a></li>
<li><a href="#org466e9e2">ngx_queue_t</a></li>
</ul>
</li>
<li><a href="#org076ea34">Configuration &amp; Directives</a>
<ul>
<li><a href="#org3d07fcf">sendfile</a></li>
<li><a href="#orgd1977e9">tcp_nopush</a></li>
<li><a href="#org03413e4">tcp_nodelay</a></li>
<li><a href="#org17ce7e3">worker_connections</a></li>
<li><a href="#org0159a53">client_header_buffer_size</a></li>
<li><a href="#orgead883f">keepalive_timeout</a></li>
<li><a href="#org0b2d635">large_client_header_buffers</a></li>
<li><a href="#org99435cf">lingering_close</a></li>
<li><a href="#org47259b1">lingering_timeout</a></li>
<li><a href="#org795d7d7">access_log</a></li>
</ul>
</li>
<li><a href="#org4ce07d9">Variables</a>
<ul>
<li><a href="#org68d945b">upstream_response_length</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<div id="outline-container-orgff43445" class="outline-2">
<h2 id="orgff43445">Nginx</h2>
<div class="outline-text-2" id="text-orgff43445">
<p>
Nginx<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>

<ul class="org-ul">
<li><a href="#org226d305">Data Structure</a></li>
<li><a href="#org076ea34">Directives</a></li>
<li><a href="#org4ce07d9">Variables</a></li>
</ul>

<blockquote>
<p>
ctx context
ccf core config
</p>
</blockquote>
</div>
<div id="outline-container-orgc12cfa0" class="outline-3">
<h3 id="orgc12cfa0">架构<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup></h3>
<div class="outline-text-3" id="text-orgc12cfa0">
<p>
生产环境下，一个 master 进程，用于加载配置文件和管理 worker 进程， worker 进程间同等竞争，处理请求。
</p>

<p>
重启 nginx (&lt; 0.8.0) : <code>kill -HUP ngin_pid</code>
</p>

<p>
首先，每个 worker 进程都是从 master 进程 <a href="20220912-linux_fork.html#ID-fe4f5bde-dd07-4119-a55e-d994e263146b">fork</a> 过来，在 master 进程里面，先建立好需要 listen 的 <a href="20220718-socket.html#ID-8f85e772-fcef-4d79-9314-c30b08caa0b1">socket</a>（listenfd）之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex ，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。
</p>

<ul class="org-ul">
<li>网络事件 - 异步非阻塞 - 高并发
<ul class="org-ul">
<li>select/poll/<a href="20220708-synchronous_asynchronous.html#ID-c0498ec3-4006-482e-aefe-373f01d46b3e">epoll</a>/kqueue</li>
<li><a href="20220708-synchronous_asynchronous.html#ID-c31e51cf-dba3-46de-a06b-a2160fda517b">Synchronous/Asynchronous</a></li>
<li><a href="20220708-concurrency_parallel.html#ID-af9f4833-5713-468e-9c11-ad8b1c23222c">Concurrency/Parallel</a></li>
<li>并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，可以理解为循环处理多个准备好的事件。</li>
</ul></li>
<li>信号</li>
<li>定时器
<ul class="org-ul">
<li>由于 epoll_wait 等函数在调用的时候是可以设置一个超时时间的，所以 nginx 借助这个超时时间来实现定时器。nginx 里面的定时器事件是放在一颗维护定时器的红黑树里面，每次在进入 epoll_wait 前，先从该红黑树里面拿到所有定时器事件的最小时间，在计算出 epoll_wait 的超时时间后进入 epoll_wait 。所以，当没有事件产生，也没有中断信号时， epoll_wait 会超时，也就是说，定时器事件到了。这时，nginx 会检查所有的超时事件，将他们的状态设置为超时，然后再去处理网络事件。由此可以看出，当我们写 nginx 代码时，在处理网络事件的回调函数时，通常做的第一个事情就是判断超时，然后再去处理网络事件。</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">while</span> <span style="color: #707183; background-color: #FFFFFF;">(</span><span style="color: #006FE0;">true</span><span style="color: #707183; background-color: #FFFFFF;">)</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #0000FF;">for</span> t <span style="color: #6434A3;">in</span> run_tasks <span style="color: #7388D6; background-color: #FFFFFF;">{</span>
        t<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #006DAF; font-style: italic;">handler</span><span style="color: #909183; background-color: #FFFFFF;">()</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #7388D6; background-color: #FFFFFF;">}</span>
    <span style="color: #006DAF;">update_time</span><span style="color: #7388D6; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">&amp;</span>now<span style="color: #7388D6; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #BA36A5;">timeout</span> <span style="color: #0000FF;">=</span> <span style="color: #D0372D;">ETERNITY</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #0000FF;">for</span> t <span style="color: #6434A3;">in</span> wait_tasks <span style="color: #7388D6; background-color: #FFFFFF;">{</span> <span style="color: #8D8D84; font-style: italic;">/* sorted already */</span>
        <span style="color: #0000FF;">if</span> <span style="color: #909183; background-color: #FFFFFF;">(</span>t<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #D0372D; font-style: italic;">time</span> <span style="color: #0000FF;">&lt;=</span> now<span style="color: #909183; background-color: #FFFFFF;">)</span> <span style="color: #909183; background-color: #FFFFFF;">{</span>
            t<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #006DAF; font-style: italic;">timeout_handler</span><span style="color: #709870; background-color: #FFFFFF;">()</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
        <span style="color: #909183; background-color: #FFFFFF;">}</span> <span style="color: #0000FF;">else</span> <span style="color: #909183; background-color: #FFFFFF;">{</span>
            <span style="color: #BA36A5;">timeout</span> <span style="color: #0000FF;">=</span> t<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #D0372D; font-style: italic;">time</span> <span style="color: #0000FF;">-</span> now<span style="color: #333333; background-color: #FFFFFF;">;</span>
            <span style="color: #0000FF;">break</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
        <span style="color: #909183; background-color: #FFFFFF;">}</span>
    <span style="color: #7388D6; background-color: #FFFFFF;">}</span>
    <span style="color: #BA36A5;">nevents</span> <span style="color: #0000FF;">=</span> <span style="color: #006DAF;">poll_function</span><span style="color: #7388D6; background-color: #FFFFFF;">(</span>events<span style="color: #333333; background-color: #FFFFFF;">,</span> timeout<span style="color: #7388D6; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #0000FF;">for</span> i <span style="color: #6434A3;">in</span> nevents <span style="color: #7388D6; background-color: #FFFFFF;">{</span>
        <span style="color: #6434A3;">task</span> <span style="color: #BA36A5;">t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
        <span style="color: #0000FF;">if</span> <span style="color: #909183; background-color: #FFFFFF;">(</span>events<span style="color: #709870; background-color: #FFFFFF;">[</span>i<span style="color: #709870; background-color: #FFFFFF;">]</span><span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #D0372D; font-style: italic;">type</span> <span style="color: #0000FF;">==</span> <span style="color: #D0372D;">READ</span><span style="color: #909183; background-color: #FFFFFF;">)</span> <span style="color: #909183; background-color: #FFFFFF;">{</span>
            t<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #BA36A5; font-style: italic;">handler</span> <span style="color: #0000FF;">=</span> read_handler<span style="color: #333333; background-color: #FFFFFF;">;</span>
        <span style="color: #909183; background-color: #FFFFFF;">}</span> <span style="color: #0000FF;">else</span> <span style="color: #909183; background-color: #FFFFFF;">{</span> <span style="color: #8D8D84; font-style: italic;">/* events[i].type == WRITE */</span>
            t<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #BA36A5; font-style: italic;">handler</span> <span style="color: #0000FF;">=</span> write_handler<span style="color: #333333; background-color: #FFFFFF;">;</span>
        <span style="color: #909183; background-color: #FFFFFF;">}</span>
        <span style="color: #006DAF;">run_tasks_add</span><span style="color: #909183; background-color: #FFFFFF;">(</span>t<span style="color: #909183; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #7388D6; background-color: #FFFFFF;">}</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5071cb7" class="outline-3">
<h3 id="org5071cb7">请求流程</h3>
<div class="outline-text-3" id="text-org5071cb7">
<p>
worker 进程的 ngx_worker_process_cycle() 函数是无限循环的处理函数，简单处理流程：
</p>
<ol class="org-ol">
<li>操作系统提供的机制（例如epoll, kqueue等）产生相关的事件。</li>
<li>接收和处理这些事件，如是接受到数据，则产生更高层的 request 对象。</li>
<li>处理 request 的 header 和 body 。</li>
<li>产生响应，并发送回客户端。</li>
<li>完成 request 的处理。</li>
<li>重新初始化定时器及其他事件。</li>
</ol>

<p>
当 nginx 读取到一个 HTTP Request 的 header 的时候， nginx 首先查找与这个请求关联的虚拟主机的配置。如果找到了这个虚拟主机的配置，那么通常情况下，这个 HTTP Request 将会经过以下几个阶段的处理（phase handlers）：
</p>
<ol class="org-ol">
<li>NGX_HTTP_POST_READ_PHASE:      读取请求内容阶段</li>
<li>NGX_HTTP_SERVER_REWRITE_PHASE: Server 请求地址重写阶段</li>
<li>NGX_HTTP_FIND_CONFIG_PHASE:    配置查找阶段:</li>
<li>NGX_HTTP_REWRITE_PHASE:        Location 请求地址重写阶段</li>
<li>NGX_HTTP_POST_REWRITE_PHASE:   请求地址重写提交阶段</li>
<li>NGX_HTTP_PREACCESS_PHASE:      访问权限检查准备阶段</li>
<li>NGX_HTTP_ACCESS_PHASE:         访问权限检查阶段</li>
<li>NGX_HTTP_POST_ACCESS_PHASE:    访问权限检查提交阶段</li>
<li>NGX_HTTP_TRY_FILES_PHASE:      配置项try_files处理阶段</li>
<li>NGX_HTTP_CONTENT_PHASE:       内容产生阶段</li>
<li>NGX_HTTP_LOG_PHASE:           日志模块处理阶段</li>
</ol>

<p>
在内容产生阶段，为了给一个 request 产生正确的响应， nginx 必须把这个 request 交给一个合适的 content handler 去处理。如果这个request对应的location在配置文件中被明确指定了一个 content handler ，那么 nginx 就可以通过对 location 的匹配，直接找到这个对应的 handler ，并把这个 request 交给这个 content handler 去处理。例如 perl, flv, proxy_pass, mp4 等。
</p>

<p>
如果一个 request 对应的 location 并没有直接有配置的 content handler ，那么 nginx 依次尝试:
</p>
<ol class="org-ol">
<li>random_index on ，那么随机选择一个文件，发送给客户端</li>
<li>index指令，那么发送 index 指令指明的文件，给客户端</li>
<li>autoindex on ，那么就发送请求地址对应的服务端路径下的文件列表给客户端</li>
<li>gzip_static on ，那么就查找是否有对应的 .gz 文件存在，有的话，就发送这个给客户端（客户端支持gzip的情况下）</li>
<li>请求的URI如果对应一个静态文件， static module 就发送静态文件的内容到客户端</li>
</ol>

<p>
内容产生阶段完成以后，生成的输出会被传递到 filter 模块去进行处理。 filter 模块也是与 location 相关的。所有的 fiter 模块都被组织成一条链。输出会依次穿越所有的 filter ，直到有一个 filter 模块的返回值表明已经处理完成。
</p>

<p>
这里列举几个常见的filter模块，例如：
</p>
<ul class="org-ul">
<li>server-side includes</li>
<li>XSLT filtering</li>
<li>图像缩放之类的</li>
<li>gzip 压缩</li>
</ul>

<p>
在所有的filter中，有几个filter模块需要关注一下。按照调用的顺序依次说明如下：
</p>
<ul class="org-ul">
<li>write:    写输出到客户端，实际上是写到连接对应的socket上</li>
<li>postpone: 这个 filter 是负责 subrequest 的，也就是子请求的</li>
<li>copy:     将一些需要复制的 buf，文件或者内存，重新复制一份然后交给剩余的 body filter 处理</li>
</ul>

<p>
nginx 将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。
</p>

<p>
图形化分析 nginx 源码可以用 Sourcetrail<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup> 。
</p>
</div>
</div>
<div id="outline-container-org021a5f8" class="outline-3">
<h3 id="org021a5f8">connection<sup><a id="fnr.2.100" class="footref" href="#fn.2" role="doc-backlink">2</a></sup></h3>
<div class="outline-text-3" id="text-org021a5f8">
<p>
nginx 中 connection 就是对 <a href="20220715-tcp.html#ID-ab245058-bb20-4a0e-b171-fde19a26b2ff">TCP</a> 连接的封装，其中包括连接的 <a href="20220718-socket.html#ID-8f85e772-fcef-4d79-9314-c30b08caa0b1">Socket </a>，读事件，写事件。利用 nginx 封装的 connection 可以很方便的使用 nginx 来处理与连接相关的事情，如 Web 服务、邮件、端口转发等。
</p>

<p>
<code>ngx_connection_t</code>
</p>

<p>
连接竞争：
nginx 的处理得先打开 accept_mutex 选项，此时，只有获得了 accept_mutex 的进程才会去添加 accept 事件，也就是说， nginx 会控制进程是否添加 accept 事件。nginx 使用一个叫 ngx_accept_disabled 的变量来控制是否去竞争 accept_mutex 锁。在第一段代码中，计算 ngx_accept_disabled 的值，这个值是 nginx 单进程的所有连接总数的八分之一减去剩下的空闲连接数量。得到的这个 ngx_accept_disabled 有一个规律，当剩余连接数小于总连接数的八分之一时，其值才大于 0，而且剩余的连接数越小，这个值越大。再看第二段代码，当 ngx_accept_disabled 大于 0 时，不会去尝试获取 accept_mutex 锁，并且将 ngx_accept_disabled 减 1 ，于是，每次执行到此处时，都会去减 1 ，直到小于 0 。
</p>

<p>
不去获取 accept_mutex 锁，就是等于让出获取连接的机会，很显然可以看出，当空余连接越少时， ngx_accept_disable 越大，于是让出的机会就越多，这样其它进程获取锁的机会也就越大。
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #BA36A5;">ngx_accept_disabled</span> <span style="color: #0000FF;">=</span> ngx_cycle<span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">connection_n</span> <span style="color: #0000FF;">/</span> <span style="color: #D0372D;">8</span>
    <span style="color: #0000FF;">-</span> ngx_cycle<span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">free_connection_n</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">if</span> <span style="color: #707183; background-color: #FFFFFF;">(</span>ngx_accept_disabled <span style="color: #0000FF;">&gt;</span> <span style="color: #D0372D;">0</span><span style="color: #707183; background-color: #FFFFFF;">)</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #BA36A5;">ngx_accept_disabled</span><span style="color: #0000FF;">--</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #707183; background-color: #FFFFFF;">}</span> <span style="color: #0000FF;">else</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #0000FF;">if</span> <span style="color: #7388D6; background-color: #FFFFFF;">(</span><span style="color: #006DAF;">ngx_trylock_accept_mutex</span><span style="color: #909183; background-color: #FFFFFF;">(</span>cycle<span style="color: #909183; background-color: #FFFFFF;">)</span> <span style="color: #0000FF;">==</span> <span style="color: #D0372D;">NGX_ERROR</span><span style="color: #7388D6; background-color: #FFFFFF;">)</span> <span style="color: #7388D6; background-color: #FFFFFF;">{</span>
        <span style="color: #0000FF;">return</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #7388D6; background-color: #FFFFFF;">}</span>

    <span style="color: #0000FF;">if</span> <span style="color: #7388D6; background-color: #FFFFFF;">(</span>ngx_accept_mutex_held<span style="color: #7388D6; background-color: #FFFFFF;">)</span> <span style="color: #7388D6; background-color: #FFFFFF;">{</span>
        <span style="color: #BA36A5;">flags</span> <span style="color: #0000FF;">|=</span> <span style="color: #D0372D;">NGX_POST_EVENTS</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #7388D6; background-color: #FFFFFF;">}</span> <span style="color: #0000FF;">else</span> <span style="color: #7388D6; background-color: #FFFFFF;">{</span>
        <span style="color: #0000FF;">if</span> <span style="color: #909183; background-color: #FFFFFF;">(</span>timer <span style="color: #0000FF;">==</span> <span style="color: #D0372D;">NGX_TIMER_INFINITE</span>
                <span style="color: #0000FF;">||</span> timer <span style="color: #0000FF;">&gt;</span> ngx_accept_mutex_delay<span style="color: #909183; background-color: #FFFFFF;">)</span>
        <span style="color: #909183; background-color: #FFFFFF;">{</span>
            <span style="color: #BA36A5;">timer</span> <span style="color: #0000FF;">=</span> ngx_accept_mutex_delay<span style="color: #333333; background-color: #FFFFFF;">;</span>
        <span style="color: #909183; background-color: #FFFFFF;">}</span>
    <span style="color: #7388D6; background-color: #FFFFFF;">}</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcd2250f" class="outline-3">
<h3 id="orgcd2250f">request</h3>
<div class="outline-text-3" id="text-orgcd2250f">
<p>
指 http 请求， <code>ngx_http_request_t</code> ，包括 请求行、请求头、请求体、响应行、响应头、响应体。
</p>

<div class="org-src-container">
<pre class="src src-nil">ngx_http_init_request
- ngx_http_process_request_line
  -- ngx_http_process_request_line
  [schema host uri version]
- ngx_http_process_request_headers
  -- ngx_http_read_request_header
     --- ngx_http_parse_header_line &gt; ngx_http_request_t-&gt;headers_in
     --- ngx_http_headers_in (e.g. ngx_http_process_host)
  [headers]
- ngx_http_process_request
  -- ngx_http_request_handler
  -- ngx_http_handler
     -- read_event_handler  &gt; ngx_http_block_reading
     *- write_event_handler &gt; ngx_http_core_run_phases &gt; headers_out
                              *- header filters: ngx_http_header_filter
                              -- ngx_http_copy_filter
                              -- body   filters: ngx_http_write_filter
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd5f2684" class="outline-3">
<h3 id="orgd5f2684"><a href="20220714-http.html#ID-fb1bee78-8741-44fd-b8a5-139902b77df2">pipe</a></h3>
<div class="outline-text-3" id="text-orgd5f2684">
<p>
nginx 支持 pipeline 的，但对 pipeline 中的多个请求的处理却不是并行的，依然是一个请求接一个请求的处理，只是在处理第一个请求的时候，客户端就可以发起第二个请求。这样，nginx 利用 pipeline 减少了处理完一个请求后，等待第二个请求的请求头数据的时间。
</p>

<p>
其实 nginx 的做法很简单，在读取数据时，会将读取的数据放到一个 buffer 里面，所以，如果 nginx 在处理完前一个请求后，如果发现 buffer 里面还有数据，就认为剩下的数据是下一个请求的开始，然后就接下来处理下一个请求，否则就设置 keepalive。
</p>
</div>
</div>
<div id="outline-container-orgb193bec" class="outline-3">
<h3 id="orgb193bec">lingering_close</h3>
<div class="outline-text-3" id="text-orgb193bec">
<p>
延迟关闭，当 nginx 要关闭连接时，并非立即关闭连接，而是先关闭 TCP 连接的写，再等待一段时间后再关掉连接的读。参考 <a href="20220718-socket.html#ID-245cbc05-7d62-4d4b-a64e-cda6ecbb12e9">SO_LINGER</a> 。
</p>

<p>
非延迟关闭的情况：
</p>
<blockquote>
<p>
nginx 在接收客户端的请求时，可能由于客户端或服务端出错了，要立即响应错误信息给客户端，而 nginx 在响应错误信息后，大分部情况下是需要关闭当前连接。nginx 执行完 write() 系统调用把错误信息发送给客户端， write() 系统调用返回成功并不表示数据已经发送到客户端，有可能还在 TCP 连接的 write buffer 里。接着如果直接执行 close() 系统调用关闭 TCP 连接，内核会首先检查 TCP 的 read buffer 里有没有客户端发送过来的数据留在内核态没有被用户态进程读取：
</p>
<ul class="org-ul">
<li>如果有则发送给客户端 RST 报文来关闭 TCP 连接丢弃 write buffer 里的数据；</li>
<li>如果没有则等待 write buffer 里的数据发送完毕，然后再经过正常的 4 次分手报文断开连接。</li>
</ul>

<p>
所以，当在某些场景下出现 TCP write buffer 里的数据在 write() 系统调用之后到 close() 系统调用执行之前没有发送完毕，且 TCP read buffer 里面还有数据没有读，close() 系统调用会导致客户端收到 RST 报文且不会拿到服务端发送过来的错误信息数据。
</p>
</blockquote>

<p>
而对于延迟关闭，只需要关掉写就行了，读可以继续进行，只需要丢掉读到的任何数据就行了，当关掉连接后，客户端再发过来的数据，就不会再收到 RST 了。
</p>
</div>
</div>
</div>
<div id="outline-container-org226d305" class="outline-2">
<h2 id="org226d305">Data Structure</h2>
<div class="outline-text-2" id="text-org226d305">
<p>
nginx-0.1.0
</p>
</div>
<div id="outline-container-org9b602ed" class="outline-3">
<h3 id="org9b602ed">ngx_str_t</h3>
<div class="outline-text-3" id="text-org9b602ed">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #006FE0;">size_t</span>    <span style="color: #BA36A5; font-style: italic;">len</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">u_char</span>   <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">data</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span> <span style="color: #6434A3;">ngx_str_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>
<p>
不以 &rsquo;\0&rsquo; 结尾，以 len 表示长度，这样可以实现字符串的浅拷贝（指针 + 长度），但是在修改字符串的时候需要十分小心。
</p>

<p>
这里特别要提醒的是，格式化 ngx_str_t 结构，其对应的转义符是 %V （nginx 自己定义的转义符），传给函数的一定要是指针类型，否则程序就会 coredump 掉。 0.1.0 未实现。
</p>
</div>
</div>
<div id="outline-container-org35864c1" class="outline-3">
<h3 id="org35864c1">ngx_pool_t</h3>
<div class="outline-text-3" id="text-org35864c1">
<p>
提供了一种机制，帮助管理一系列的资源（如内存，文件等），使得对这些资源的使用和释放统一进行。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_pool_s</span>        <span style="color: #6434A3;">ngx_pool_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_pool_s</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #006FE0;">char</span>              <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">last</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">char</span>              <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">end</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_pool_t</span>        <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">next</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_pool_large_t</span>  <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">large</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_log_t</span>         <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">log</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_pool_cleanup_s</span>  <span style="color: #6434A3;">ngx_pool_cleanup_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #0000FF;">typedef</span> <span style="color: #006FE0;">void</span> <span style="color: #707183; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">*</span><span style="color: #6434A3;">ngx_pool_cleanup_pt</span><span style="color: #707183; background-color: #FFFFFF;">)(</span><span style="color: #006FE0;">void</span> <span style="color: #0000FF;">*</span><span style="color: #BA36A5;">data</span><span style="color: #707183; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #8D8D84; font-style: italic;">/* ngx_pool_cleanup_pt &#26159;&#25351;&#38024;&#65292;&#25351;&#21521; &#27809;&#26377;&#36820;&#22238;&#20540;&#30340; &#25509;&#21463;&#19968;&#20010;&#25351;&#38024;&#31867;&#22411; &#30340;&#21442;&#25968; &#30340;&#20989;&#25968; &#30340;&#21035;&#21517; */</span>

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_pool_cleanup_s</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #6434A3;">ngx_pool_cleanup_pt</span>   <span style="color: #BA36A5; font-style: italic;">handler</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">void</span>                 <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">data</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_pool_cleanup_t</span>   <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">next</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org71fbe09" class="outline-3">
<h3 id="org71fbe09">ngx_array_t</h3>
<div class="outline-text-3" id="text-org71fbe09">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_array_s</span>       <span style="color: #6434A3;">ngx_array_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_array_s</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #006FE0;">void</span>        <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">elts</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_uint_t</span>   <span style="color: #BA36A5; font-style: italic;">nelts</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">size_t</span>       <span style="color: #BA36A5; font-style: italic;">size</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_uint_t</span>   <span style="color: #BA36A5; font-style: italic;">nalloc</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_pool_t</span>  <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">pool</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #8D8D84; font-style: italic;">/*</span>
<span style="color: #8D8D84; font-style: italic;">elts:    &#25351;&#21521;&#23454;&#38469;&#30340;&#25968;&#25454;&#23384;&#20648;&#21306;&#22495;&#12290;</span>
<span style="color: #8D8D84; font-style: italic;">nelts:   &#25968;&#32452;&#23454;&#38469;&#20803;&#32032;&#20010;&#25968;&#12290;</span>
<span style="color: #8D8D84; font-style: italic;">size:    &#25968;&#32452;&#21333;&#20010;&#20803;&#32032;&#30340;&#22823;&#23567;&#65292;&#21333;&#20301;&#26159;&#23383;&#33410;&#12290;</span>
<span style="color: #8D8D84; font-style: italic;">nalloc:  &#25968;&#32452;&#30340;&#23481;&#37327;&#12290;&#34920;&#31034;&#35813;&#25968;&#32452;&#22312;&#19981;&#24341;&#21457;&#25193;&#23481;&#30340;&#21069;&#25552;&#19979;&#65292;&#21487;&#20197;&#26368;&#22810;&#23384;&#20648;&#30340;&#20803;&#32032;&#30340;&#20010;&#25968;&#12290;&#24403; nelts &#22686;&#38271;&#21040;&#36798; nalloc  &#26102;&#65292;&#22914;&#26524;&#20877;&#24448;&#27492;&#25968;&#32452;&#20013;&#23384;&#20648;&#20803;&#32032;&#65292;&#21017;&#20250;&#24341;&#21457;&#25968;&#32452;&#30340;&#25193;&#23481;&#12290;&#25968;&#32452;&#30340;&#23481;&#37327;&#23558;&#20250;&#25193;&#23637;&#21040;&#21407;&#26377;&#23481;&#37327;&#30340; 2 &#20493;&#22823;&#23567;&#12290;&#23454;&#38469;&#19978;&#26159;&#20998;&#37197;&#26032;&#30340;&#19968;&#22359;&#20869;&#23384;&#65292;&#26032;&#30340;&#19968;&#22359;&#20869;&#23384;&#30340;&#22823;&#23567;&#26159;&#21407;&#26377;&#20869;&#23384;&#22823;&#23567;&#30340; 2 &#20493;&#12290;&#21407;&#26377;&#30340;&#25968;&#25454;&#20250;&#34987;&#25335;&#36125;&#21040;&#26032;&#30340;&#19968;&#22359;&#20869;&#23384;&#20013;&#12290;</span>
<span style="color: #8D8D84; font-style: italic;">pool:    &#35813;&#25968;&#32452;&#29992;&#26469;&#20998;&#37197;&#20869;&#23384;&#30340;&#20869;&#23384;&#27744;&#12290;</span>
<span style="color: #8D8D84; font-style: italic;">*/</span>
</pre>
</div>
<p>
由于使用 ngx_palloc 分配内存，数组在扩容时，旧的内存不会被释放，会造成内存的浪费。
</p>
</div>
</div>
<div id="outline-container-orga35044f" class="outline-3">
<h3 id="orga35044f">ngx_hash_t</h3>
<div class="outline-text-3" id="text-orga35044f">
<p>
0.1.0 未实现。
</p>

<p>
对于常用的解决冲突的方法有线性探测，二次探测和开链法等。ngx_hash_t 使用的是最常用的一种，也就是开链法，这也是 STL 中的 hash 表使用的方法。
</p>
<ol class="org-ol">
<li>ngx_hash_t 不像其他的 hash 表的实现，可以插入删除元素，它只能一次初始化，就构建起整个 hash 表。之后既不能删除，也不能插入元素；</li>
<li>ngx_hash_t 的开链并不是真的开了一个链表，实际上是开了一段连续的存储空间，几乎可以看做是一个数组。这是因为 ngx_hash_t 在初始化的时候，会经历一次预计算的过程，提前把每个桶里面会有多少元素放进去给计算出来，这样就提前知道每个桶的大小了。那么就不需要使用链表，一段连续的存储空间就足够了。这也从一定程度上节省了内存的使用。</li>
</ol>
</div>
</div>
<div id="outline-container-org8582ebf" class="outline-3">
<h3 id="org8582ebf">ngx_chain_t</h3>
<div class="outline-text-3" id="text-org8582ebf">
<p>
nginx 的 filter 模块在处理从别的 filter 模块或者是 handler 模块传递过来的数据（实际上就是需要发送给客户端的http response）。这个传递过来的数据是以一个链表的形式 ngx_chain_t 。而且数据可能被分多次传递过来。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_chain_s</span>       <span style="color: #6434A3;">ngx_chain_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_chain_s</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #6434A3;">ngx_buf_t</span>    <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">buf</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_chain_t</span>  <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">next</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga3a75b7" class="outline-3">
<h3 id="orga3a75b7">ngx_buf_t</h3>
<div class="outline-text-3" id="text-orga3a75b7">
<p>
ngx_buf_t 就是 ngx_chain_t 链表的每个节点的实际数据。该结构实际上是一种抽象的数据结构，它代表某种具体的数据。这个数据可能是指向内存中的某个缓冲区，也可能指向一个文件的某一部分，也可能是一些纯元数据（元数据的作用在于指示这个链表的读取者对读取的数据进行不同的处理）。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_buf_s</span>  <span style="color: #6434A3;">ngx_buf_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_buf_s</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #6434A3;">u_char</span>          <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">pos</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">u_char</span>          <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">last</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">off_t</span>            <span style="color: #BA36A5; font-style: italic;">file_pos</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">off_t</span>            <span style="color: #BA36A5; font-style: italic;">file_last</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #006FE0;">int</span>              <span style="color: #BA36A5; font-style: italic;">type</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">u_char</span>          <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">start</span><span style="color: #333333; background-color: #FFFFFF;">;</span>         <span style="color: #8D8D84; font-style: italic;">/* start of buffer */</span>
    <span style="color: #6434A3;">u_char</span>          <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">end</span><span style="color: #333333; background-color: #FFFFFF;">;</span>           <span style="color: #8D8D84; font-style: italic;">/* end of buffer */</span>
    <span style="color: #6434A3;">ngx_buf_tag_t</span>    <span style="color: #BA36A5; font-style: italic;">tag</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_file_t</span>      <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">file</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_buf_t</span>       <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">shadow</span><span style="color: #333333; background-color: #FFFFFF;">;</span>


    <span style="color: #8D8D84; font-style: italic;">/* the buf's content could be changed */</span>
    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">temporary</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #8D8D84; font-style: italic;">/*</span>
<span style="color: #8D8D84; font-style: italic;">     * the buf's content is in a memory cache or in a read only memory</span>
<span style="color: #8D8D84; font-style: italic;">     * and must not be changed</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">memory</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #8D8D84; font-style: italic;">/* the buf's content is mmap()ed and must not be changed */</span>
    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">mmap</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">recycled</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">in_file</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">flush</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">last_buf</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">last_shadow</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">temp_file</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #006FE0;">unsigned</span>         <span style="color: #BA36A5; font-style: italic;">zerocopy_busy</span>:<span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #8D8D84; font-style: italic;">/* STUB */</span> <span style="color: #006FE0;">int</span>   <span style="color: #BA36A5; font-style: italic;">num</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd9634fd" class="outline-3">
<h3 id="orgd9634fd">ngx_list_t</h3>
<div class="outline-text-3" id="text-orgd9634fd">
<p>
ngx_list_t 的节点实际上是一个固定大小的数组，首节点需要初始化（自身），之后的节点为 ngx_list_part_t 结构。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_list_part_s</span>  <span style="color: #6434A3;">ngx_list_part_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_list_part_s</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #006FE0;">void</span>             <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">elts</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_uint_t</span>        <span style="color: #BA36A5; font-style: italic;">nelts</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_list_part_t</span>  <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">next</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #6434A3;">ngx_list_part_t</span>  <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">last</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_list_part_t</span>   <span style="color: #BA36A5; font-style: italic;">part</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #006FE0;">size_t</span>            <span style="color: #BA36A5; font-style: italic;">size</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_uint_t</span>        <span style="color: #BA36A5; font-style: italic;">nalloc</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_pool_t</span>       <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">pool</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span> <span style="color: #6434A3;">ngx_list_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org466e9e2" class="outline-3">
<h3 id="org466e9e2">ngx_queue_t</h3>
<div class="outline-text-3" id="text-org466e9e2">
<p>
0.1.0 未实现。
</p>

<p>
ngx_queue_t 是一种的双向链表。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_queue_s</span> <span style="color: #6434A3;">ngx_queue_t</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">ngx_queue_s</span> <span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #6434A3;">ngx_queue_t</span>  <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">prev</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
    <span style="color: #6434A3;">ngx_queue_t</span>  <span style="color: #0000FF;">*</span><span style="color: #BA36A5; font-style: italic;">next</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>

<p>
ngx_queue_t 只是声明了前向和后向指针。在使用的时候，我们首先需要定义一个哨兵节点（对于后续具体存放数据的节点，我们称之为数据节点），比如：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">ngx_queue_t</span> <span style="color: #BA36A5;">free</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>
<p>
接下来初始化：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #006DAF;">ngx_queue_init</span><span style="color: #707183; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">&amp;</span>free<span style="color: #707183; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

<span style="color: #808080;">#define</span> <span style="color: #006699;">ngx_queue_init</span><span style="color: #707183; background-color: #FFFFFF;">(</span><span style="color: #BA36A5;">q</span><span style="color: #707183; background-color: #FFFFFF;">)</span>     \
    <span style="color: #707183;">(</span>q<span style="color: #707183;">)</span>-&gt;prev = q;            \
    <span style="color: #707183;">(</span>q<span style="color: #707183;">)</span>-&gt;next = q;
</pre>
</div>
<p>
q-&gt;next 头节点； q-&gt;prev 尾节点。
</p>

<p>
取 middle 节点， middle 向后移动 1 步， next 向后移动 2 步，当 next 等于尾节点时，此时 middle 就指向中间节点，时间复杂度 O(N) 。
</p>
</div>
</div>
</div>
<div id="outline-container-org076ea34" class="outline-2">
<h2 id="org076ea34">Configuration &amp; Directives</h2>
<div class="outline-text-2" id="text-org076ea34">
<p>
在 nginx.conf 中，包含若干配置项。每个配置项由配置指令和指令参数 2 个部分构成。指令参数也就是配置指令对应的配置值。
</p>

<p>
指令概述：配置指令是一个字符串，可以用单引号或者双引号括起来，也可以不括。但是如果配置指令包含空格，一定要引起来。
</p>

<p>
指令参数：指令的参数使用一个或者多个空格或者 TAB 字符与指令分开。指令的参数有一个或者多个 TOKEN 串组成。 TOKEN 串之间由空格或者 TAB 键分隔。TOKEN 串分为简单字符串或者是复合配置块。复合配置块即是由大括号括起来的一堆内容。一个复合配置块中可能包含若干其他的配置指令。
</p>

<p>
环境上下文： main http server location mail 。
</p>

<p>
模块：nginx 将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。模块的分类：
</p>
<ul class="org-ul">
<li>event module</li>
<li>phase handler</li>
<li>output filter</li>
<li>upstream</li>
<li>load-balancer</li>
</ul>
</div>
<div id="outline-container-org3d07fcf" class="outline-3">
<h3 id="org3d07fcf">sendfile</h3>
<div class="outline-text-3" id="text-org3d07fcf">
<p>
默认 off ，配置是否由 Linux 内核直接读取文件（ <a href="20220724-linux.html#ID-a22d50a1-2a30-499c-b6f7-25d65e2016e3">System Call</a> ），而不是通过 read, write 来操作。
</p>
</div>
</div>
<div id="outline-container-orgd1977e9" class="outline-3">
<h3 id="orgd1977e9">tcp_nopush</h3>
<div class="outline-text-3" id="text-orgd1977e9">
<p>
默认 off ，配置是否开启 socket 的 <a href="20220718-socket.html#ID-8d1430e6-40a0-4ec5-92bf-53c3c8d5864f"><code>TCP_CORK</code></a> 选项。
</p>
</div>
</div>
<div id="outline-container-org03413e4" class="outline-3">
<h3 id="org03413e4">tcp_nodelay</h3>
<div class="outline-text-3" id="text-org03413e4">
<p>
默认 on ，配置是否关闭 nagle 算法，即 <a href="20220718-socket.html#ID-8f561f8b-dcb8-412d-89fe-bb5d51641fc9"><code>TCP_NODELAY</code></a> 选项。
</p>
</div>
</div>
<div id="outline-container-org17ce7e3" class="outline-3">
<h3 id="org17ce7e3">worker_connections</h3>
<div class="outline-text-3" id="text-org17ce7e3">
<p>
默认 1024 ，代表每个 worker 进程的一个 worker_connections 大小的一个 ngx_connection_t 结构的数组。并且，nginx 会通过一个链表 free_connections 来保存所有的空闲 ngx_connection_t ，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。
</p>

<p>
对于静态资源服务器， nginx 的最大连接数为： worker_connections × worker_processes ；
对于反向代理服务器， nginx 的最大连接数为： worker_connections × worker_processes / 2 。
</p>
</div>
</div>
<div id="outline-container-org0159a53" class="outline-3">
<h3 id="org0159a53">client_header_buffer_size</h3>
<div class="outline-text-3" id="text-org0159a53">
<p>
nginx 会将整个请求头都放在 buffer 里面，配置这个 buffer 的大小。
</p>
</div>
</div>
<div id="outline-container-orgead883f" class="outline-3">
<h3 id="orgead883f">keepalive_timeout</h3>
<div class="outline-text-3" id="text-orgead883f">
<p>
默认 60 ，配置长连接的超时时间。
</p>
</div>
</div>
<div id="outline-container-org0b2d635" class="outline-3">
<h3 id="org0b2d635">large_client_header_buffers</h3>
<div class="outline-text-3" id="text-org0b2d635">
<p>
默认 4 8k ，表示 4 个 8k 的 buffer ，在 client_header_buffer_size 装不下， nginx 重新分配一个更大的 buffer 情况下，这个 buffer 的数量和大小。
</p>

<p>
请求行大于 buffer ，返回 414 ；请求头大于 buffer ，返回 400 。
</p>
</div>
</div>
<div id="outline-container-org99435cf" class="outline-3">
<h3 id="org99435cf">lingering_close</h3>
<div class="outline-text-3" id="text-org99435cf">
<p>
配置开启或关闭延迟关闭。
</p>
</div>
</div>
<div id="outline-container-org47259b1" class="outline-3">
<h3 id="org47259b1">lingering_timeout</h3>
<div class="outline-text-3" id="text-org47259b1">
<p>
配置延迟关闭超时时间。
</p>
</div>
</div>
<div id="outline-container-org795d7d7" class="outline-3">
<h3 id="org795d7d7">access_<a href="20220802-log.html#ID-b69b104b-4d85-475e-a73c-1726bf511048">log</a></h3>
<div class="outline-text-3" id="text-org795d7d7">
<div class="org-src-container">
<pre class="src src-nginx">log_format combined '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
access_log logs/access.log combined;
</pre>
</div>
<p>
使用 JSON 格式：
</p>
<div class="org-src-container">
<pre class="src src-nginx">log_format json_analytics escape=json '{'
    '"msec": "$msec", '                                         # request unixtime in seconds with a milliseconds resolution
    '"connection": "$connection", '                             # connection serial number
    '"connection_requests": "$connection_requests", '           # number of requests made in connection
    '"pid": "$pid", '                                           # process pid
    '"request_id": "$request_id", '                             # the unique request id
    '"request_length": "$request_length", '                     # request length (including headers and body)
    '"remote_addr": "$remote_addr", '                           # client IP
    '"remote_user": "$remote_user", '                           # client HTTP username
    '"remote_port": "$remote_port", '                           # client port
    '"time_local": "$time_local", '
    '"time_iso8601": "$time_iso8601", '                         # local time in the ISO 8601 standard format
    '"request": "$request", '                                   # full path no arguments if the request
    '"request_uri": "$request_uri", '                           # full path and arguments if the request
    '"args": "$args", '
    '"status": "$status", '                                     # response status code
    '"body_bytes_sent": "$body_bytes_sent", '                   # the number of body bytes exclude headers sent to a client
    '"bytes_sent": "$bytes_sent", '                             # the number of bytes sent to a client
    '"referer": "$http_referer", '
    '"user_agent": "$http_user_agent", '
    '"x_forwarded_for": "$http_x_forwarded_for", '              # http_x_forwarded_for
    '"host": "$http_host", '                                    # the request Host: header
    '"server_name": "$server_name", '                           # the name of the vhost serving the request
    '"request_time": "$request_time", '                         # request processing time in seconds with msec resolution
    '"upstream": "$upstream_addr", '                            # upstream backend server for proxied requests
    '"upstream_connect_time": "$upstream_connect_time", '       # upstream handshake time incl. TLS
    '"upstream_header_time": "$upstream_header_time", '         # time spent receiving upstream headers
    '"upstream_response_time": "$upstream_response_time", '     # time spend receiving upstream body
    '"upstream_response_length": "$upstream_response_length", ' # upstream response length
    '"upstream_cache_status": "$upstream_cache_status", '       # cache HIT/MISS where applicable
    '"ssl_protocol": "$ssl_protocol", '                         # TLS protocol
    '"ssl_cipher": "$ssl_cipher", '                             # TLS cipher
    '"scheme": "$scheme", '                                     # http or https
    '"request_method": "$request_method", '                     # request method
    '"server_protocol": "$server_protocol", '                   # request protocol, like HTTP/1.1 or HTTP/2.0
    '"geoip_country_code": "$geoip_country_code", '
    '"geoip_city": "$geoip_city"'
'}';

access_log     /var/data/log/nginx/json_access.log json_analytics buffer=4k flush=60 if=$logable;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org4ce07d9" class="outline-2">
<h2 id="org4ce07d9">Variables</h2>
<div class="outline-text-2" id="text-org4ce07d9">
</div>
<div id="outline-container-org68d945b" class="outline-3">
<h3 id="org68d945b">upstream_response_length</h3>
<div class="outline-text-3" id="text-org68d945b">
<blockquote>
<p>
$upstream_response_length
keeps the length of the response obtained from the upstream server (0.7.27); the length is kept in bytes. Lengths of several responses are separated by commas and colons like addresses in the $upstream_addr variable.
</p>
</blockquote>
<p>
<code>upstream_response_length</code> 在配置了 <code>error_page</code> 等内部重定向时为 0。
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://nginx.org">https://nginx.org</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="http://tengine.taobao.org/book/chapter_02.html">http://tengine.taobao.org/book/chapter_02.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://zhuanlan.zhihu.com/p/393696909">https://zhuanlan.zhihu.com/p/393696909</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<a href="https://beian.miit.gov.cn" target="_blank">湘ICP备19014083号-1</a>
</div>
</body>
</html>
