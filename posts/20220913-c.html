<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-05-28 Sun 00:55 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C &amp; C++</title>
<meta name="author" content="Honbey Zhang" />
<meta name="generator" content="Org Mode" />

                     <link rel="stylesheet" href="../resources/src/readtheorg_theme/css/htmlize.css" type="text/css"/>
                     <link rel="stylesheet" href="../resources/src/readtheorg_theme/css/readtheorg.css" type="text/css"/>
                     <script type="text/javascript" src="../resources/src/lib/js/jquery.min.js"></script>
                     <script type="text/javascript" src="../resources/src/lib/js/bootstrap.min.js"></script>
                     <script type="text/javascript" src="../resources/src/lib/js/jquery.stickytableheaders.min.js"></script>
                     <script type="text/javascript" src="../resources/src/readtheorg_theme/js/readtheorg.js"></script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">C &amp; C++</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#ID-42ed9c4f-6798-4356-8e33-b4128375ece3">C</a>
<ul>
<li><a href="#org6081c25">Clockwise/Spiral Rule</a></li>
<li><a href="#org0bc738a">Pointer</a></li>
<li><a href="#org7c2c96a">library function</a>
<ul>
<li><a href="#orgc631788">printf() - stdio.h</a></li>
<li><a href="#org275234d">memchr() - mem.h</a></li>
<li><a href="#orge580b80">offsetof - stddef.h</a></li>
</ul>
</li>
<li><a href="#org6dbe806">typedef</a></li>
<li><a href="#orgd5433d7">struct</a></li>
<li><a href="#orge79737f">array</a></li>
<li><a href="#org1acfae3">memory</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-ID-42ed9c4f-6798-4356-8e33-b4128375ece3" class="outline-2">
<h2 id="ID-42ed9c4f-6798-4356-8e33-b4128375ece3">C</h2>
<div class="outline-text-2" id="text-ID-42ed9c4f-6798-4356-8e33-b4128375ece3">
<ul class="org-ul">
<li><a href="20220912-linux_fork.html#ID-fe4f5bde-dd07-4119-a55e-d994e263146b">Linux fork()</a></li>
</ul>

<blockquote>
<p>
a.out(assembler output) 最初是一种格式，已废弃，但名称保留下来了<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>。
</p>
</blockquote>
</div>

<div id="outline-container-org6081c25" class="outline-3">
<h3 id="org6081c25">Clockwise/Spiral Rule<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup></h3>
<div class="outline-text-3" id="text-org6081c25">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> (*<span style="color: #006699;">signal</span>(<span style="color: #6434A3;">int</span>, <span style="color: #6434A3;">void</span> (*<span style="color: #006699;">fp</span>)(<span style="color: #6434A3;">int</span>)))(<span style="color: #6434A3;">int</span>);
</pre>
</div>

<figure id="org8312b5e">
<img src="../images/c_cpp_clockwise_spiral_rule_1.png" alt="c_cpp_clockwise_spiral_rule_1.png">

</figure>
</div>
</div>
<div id="outline-container-org0bc738a" class="outline-3">
<h3 id="org0bc738a">Pointer</h3>
<div class="outline-text-3" id="text-org0bc738a">
<p>
指针与指针的相减操作，表示两个指针指向的内存位置之间相隔多少个元素(注意是元素，并不是字节数)。
</p>

<p>
例如对于 int 类型的指针 p 和 p1 ，p1-p 的意义表示他们之间相隔多少个 int 类型的元素。同样对于其他类型的指针变量之间相减的意义也是一样。
</p>

<p>
数组名 a 和指针 p 之间有一个不同之处，指针是一个变量，因此，在 C 语言中，语句 p = a, p++ 都是合法的。但数组名不是变量，类似于 a = p, 和 a++ 形式的语句是非法的。
</p>

<p>
有效的指针运算（其他所有形式的指针运算都是非法的）：
</p>
<ol class="org-ol">
<li>相同类型指针之间的赋值运算</li>
<li>指针同整数之间的加法或减法运算</li>
<li>指向相同数组中的元素的两个指针间的减法或比较运算</li>
<li>将指针赋值为 0 或指针与 0 之间的比较运算</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Func</span>(<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">x</span>) { <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">&#22768;&#26126;&#19968;&#20010;&#20989;&#25968;</span><span style="color: #8D8D84;">*/</span>
  printf(<span style="color: #008000;">"%d"</span>,x);
}

<span style="color: #6434A3;">void</span> (*<span style="color: #006699;">p</span>) (<span style="color: #6434A3;">int</span>);  <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">&#23450;&#20041;&#19968;&#20010;&#20989;&#25968;&#25351;&#38024;</span><span style="color: #8D8D84;">*/</span>
p = Func;         <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">&#23558; Func &#20989;&#25968;&#30340;&#39318;&#22320;&#22336;&#36171;&#32473;&#25351;&#38024;&#21464;&#37327; p</span><span style="color: #8D8D84;"> */</span>

(*p)(a, b);       <span style="color: #8D8D84;">/*</span><span style="color: #8D8D84; font-style: italic;">&#36890;&#36807;&#20989;&#25968;&#25351;&#38024;&#35843;&#29992; Func &#20989;&#25968;</span><span style="color: #8D8D84;"> */</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7c2c96a" class="outline-3">
<h3 id="org7c2c96a">library function</h3>
<div class="outline-text-3" id="text-org7c2c96a">
</div>
<div id="outline-container-orgc631788" class="outline-4">
<h4 id="orgc631788">printf() - stdio.h</h4>
<div class="outline-text-4" id="text-orgc631788">
<div class="org-src-container">
<pre class="src src-nil">%5d 5位宽 整型

%+5d 带正负号的5位宽 整型

%-5d 左对齐5位宽 整型

%05d 5位宽，不足补零 整型

%5.2f 显示两位小数点的5位宽 浮点型

%#5x 带前缀的5位宽十六进制 整型
</pre>
</div>
</div>
</div>
<div id="outline-container-org275234d" class="outline-4">
<h4 id="org275234d">memchr() - mem.h</h4>
<div class="outline-text-4" id="text-org275234d">
<p>
在参数 str 所指向的字符串的前 n 个字节中搜索第一次出现字符 c（一个无符号字符）的位置。
</p>
<div class="org-src-container">
<pre class="src src-nil">void *memchr(const void *str, int c, size_t n)
</pre>
</div>
</div>
</div>
<div id="outline-container-orge580b80" class="outline-4">
<h4 id="orge580b80">offsetof - stddef.h</h4>
<div class="outline-text-4" id="text-orge580b80">
<p>
linux 宏定义函数 offsetof 是算出 MEMBER 在 TYPE 中的偏移：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">Offset of member MEMBER in a struct of type TYPE.</span><span style="color: #8D8D84;"> */</span>
<span style="color: #808080;">#define</span> <span style="color: #006699;">offsetof</span>(<span style="color: #BA36A5;">TYPE</span>, <span style="color: #BA36A5;">MEMBER</span>) __builtin_offsetof (TYPE, MEMBER)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6dbe806" class="outline-3">
<h3 id="org6dbe806">typedef</h3>
<div class="outline-text-3" id="text-org6dbe806">
<p>
typedef 关键字用于定义别名。
一般用法：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span>    <span style="color: #6434A3;">T</span>    <span style="color: #6434A3;">Alias</span>;
</pre>
</div>

<p>
函数：     <code>char *f(int, unsigned, float, const char *)</code>
函数指针： <code>char *(*fp)(int, unsigned, float, const char *)</code>
定义上述函数指针的别名：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #6434A3;">char</span> *(*<span style="color: #6434A3;">FP</span>)(<span style="color: #6434A3;">int</span>, <span style="color: #6434A3;">unsigned</span>, <span style="color: #6434A3;">float</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span> *);

<span style="color: #6434A3;">FP</span> <span style="color: #BA36A5;">fp</span> = f; <span style="color: #8D8D84;">/* </span><span style="color: #8D8D84; font-style: italic;">define and assign fp point to function f</span><span style="color: #8D8D84;"> */</span>
</pre>
</div>

<p>
类型是 void (*)(int) ，即参数一个int，什么也不返回的函数指针，定义的别名是 fp_t ：
</p>
<div class="org-src-container">
<pre class="src src-nil">typedef char (*fp_t)(int);
</pre>
</div>

<p>
把 a 声明为具有 10 个 int 元素的数组的类型别名：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #6434A3;">int</span> <span style="color: #6434A3;">a</span>[<span style="color: #D0372D;">10</span>];
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd5433d7" class="outline-3">
<h3 id="orgd5433d7">struct</h3>
<div class="outline-text-3" id="text-orgd5433d7">
<p>
结构体的 {, } 格式只能用于赋值时初始化，即声明并初始化，而不能直接赋值给一个已经声明的结构体变量。或按照 c99 标准先强制类型转换。
</p>
</div>
</div>
<div id="outline-container-orge79737f" class="outline-3">
<h3 id="orge79737f">array</h3>
<div class="outline-text-3" id="text-orge79737f">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">a</span>[<span style="color: #D0372D;">3</span>][<span style="color: #D0372D;">2</span>];
</pre>
</div>
<p>
某种意义上是 C 语言是没有列这个概念的严格来讲，C 没有多维数组，只有数组的数组：
</p>
<ul class="org-ul">
<li>对于一维数组，比如 <code>int a[2];</code>    ，是指连续放 2 个 int</li>
<li>对于多维数组，比如 <code>int a[3][2];</code> ，是指连续放 3 个 int[2] ，最终效果就是连续放了 6 个 int</li>
</ul>
</div>
</div>
<div id="outline-container-org1acfae3" class="outline-3">
<h3 id="org1acfae3">memory</h3>
<div class="outline-text-3" id="text-org1acfae3">
<p>
使用内存池分配内存有几点好处：
</p>
<ul class="org-ul">
<li>提升内存分配效率。不需要每次分配内存都执行 malloc/alloc 等函数</li>
<li>让内存的管理变得更加简单。内存的分配都会在一块大的内存上，回收的时候只需要回收大块内存就能将所有的内存回收，防止了内存管理混乱和内存泄露问题</li>
</ul>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="https://wangdoc.com/clang/intro.html">C 语言简介 - C 语言教程 - 网道</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
<a href="http://c-faq.com/decl/spiral.anderson.html">Clockwise/Spiral Rule</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">

                     Theme
                     <a href="https://github.com/fniessen/org-html-themes" target="_blank">bigblow/readtheorg</a>
                     by
                     <a href="https://github.com/fniessen" target="_blank">fniessen</a>
                     <br>
                     <a href="https://beian.miit.gov.cn" target="_blank">湘ICP证019014083号</a>
</div>
</body>
</html>