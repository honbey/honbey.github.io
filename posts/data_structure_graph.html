<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-09-12 Mon 22:21 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>图</title>
<meta name="author" content="Honbey Zhang" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="../resources/orgmode.css" type="text/css"/>
                     <link rel="stylesheet" href="../resources/style.css" type="text/css"/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">图</h1>
</header><p>
图片来源于图书馆借的《算法（第 4 版）》一书，为了加深印象，对照书的图用 visio 画了一遍。
</p>

<div id="outline-container-org382ed3e" class="outline-2">
<h2 id="org382ed3e">图的表示法</h2>
<div class="outline-text-2" id="text-org382ed3e">
</div>
<div id="outline-container-orgdfe2034" class="outline-3">
<h3 id="orgdfe2034">邻接矩阵表示法</h3>
<div class="outline-text-3" id="text-orgdfe2034">
<p>
对于任意图（设其顶点个数为 n），其邻接矩阵是一个 n×n 的二维数组，若 (0, 1) 是 G 的一条边，则其邻接矩阵 a[0][1] =1，若不是，则 a[0][1] = 0 。而且无向图的邻接矩阵一定是对称的。无向图的邻接矩阵只需存储其上三角或者其上三角部分。
</p>

<p>
对于一个有向图，顶点 i 所对应的 <b>行中的数字之和等于顶点 i 的出度</b> ，对应的 <b>列中的数字之和等于顶点 i 的入度</b> 。
</p>

<figure id="org8d87c82">
<img src="../images/data_structure_graph_adjoin_matrix_1.png" alt="data_structure_graph_adjoin_matrix_1.png">

</figure>
</div>
</div>

<div id="outline-container-org6cd5580" class="outline-3">
<h3 id="org6cd5580">邻接表表示法</h3>
<div class="outline-text-3" id="text-org6cd5580">
<p>
对于有 n 个结点，e 条边的无向图，采用邻接表存储表示需要存储 <b>n 个头结点和 2e 个表结点</b> ，每个结点有两个域。同时，对于有 n 个结点，e 条边的无向图，可以在 \(O(n+e)\)  时间内确定无向图中边的总数。而对于有向图，通过对某个顶点的链表中的结点计数，可以得到该顶点的出度，但是对于该顶点的入度很难确定
</p>

<figure id="orgba16837">
<img src="../images/data_structure_graph_adjoin_table_1.png" alt="data_structure_graph_adjoin_table_1.png">

</figure>
</div>
</div>

<div id="outline-container-org426ece5" class="outline-3">
<h3 id="org426ece5">邻接矩阵与邻接表相互转换</h3>
<div class="outline-text-3" id="text-org426ece5">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Trans_MtoL</span>(<span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>, <span style="color: #6434A3;">Lgraph</span> <span style="color: #BA36A5;">Gl</span>) {
    <span style="color: #6434A3;">Vnode</span> *<span style="color: #BA36A5;">p</span>, *<span style="color: #BA36A5;">q</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">e</span>, <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++) {
        Gl[i].data = i;
        Gl[i].next = <span style="color: #D0372D;">NULL</span>;
    }
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++) {
        <span style="color: #0000FF;">for</span> (j = i+<span style="color: #D0372D;">1</span>;j &lt;= n &amp;&amp; G[i][j] == <span style="color: #D0372D;">1</span>; j++) {
            p = (<span style="color: #6434A3;">Vnode</span> *)malloc(<span style="color: #0000FF;">sizeof</span>(Vnode));
            p-&gt;data = i;
            p-&gt;next = Gl[j].next;
            Gl[j].next = p;
            q = (<span style="color: #6434A3;">Vnode</span> *)malloc(<span style="color: #0000FF;">sizeof</span>(Vnode));
            q-&gt;data = j;
            q-&gt;next = Gl[i].next;
            Gl[i].next = q;
        }
    }
    printf(<span style="color: #008000;">"&#37051;&#25509;&#30697;&#38453;&#34920;&#31034;&#22914;&#19979;&#65306;\n"</span>);
    Output_mg(G);
    printf(<span style="color: #008000;">"\n &#37051;&#25509;&#34920;&#34920;&#31034;&#22914;&#19979; &#65306;"</span>);
    Output_L(Gl);
}

<span style="color: #6434A3;">void</span> <span style="color: #006699;">Trans_LtoM</span>(<span style="color: #6434A3;">Lgraph</span> <span style="color: #BA36A5;">Gl</span>, <span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>) {
    <span style="color: #6434A3;">Vnode</span> *<span style="color: #BA36A5;">p</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++)
            <span style="color: #0000FF;">for</span> (j = <span style="color: #D0372D;">1</span>; j &lt;= n; j++)
                G[i][j] = <span style="color: #D0372D;">0</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">2</span>;i &lt;= n; i++) {
        p = Gl[i].next;
        <span style="color: #0000FF;">while</span> (p != <span style="color: #D0372D;">NULL</span>) {
            j = p-&gt;data;
            G[i][j] = <span style="color: #D0372D;">1</span>;
            G[j][i] = <span style="color: #D0372D;">1</span>;
            p = p-&gt;next;
        }
    }
    printf(<span style="color: #008000;">" &#37051;&#25509;&#34920;&#34920;&#31034;&#22914;&#19979; &#65306;\n"</span>);
    Output_L(Gl);
    printf(<span style="color: #008000;">"\n&#37051;&#25509;&#30697;&#38453;&#34920;&#31034;&#22914;&#19979;&#65306;"</span>);
    Output_mg(G);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org39a5097" class="outline-3">
<h3 id="org39a5097">其他表示法</h3>
<div class="outline-text-3" id="text-org39a5097">

<figure id="orgcdc2054">
<img src="../images/data_structure_graph_mixed_expression_1.png" alt="data_structure_graph_mixed_expression_1.png">

</figure>
</div>
</div>
</div>

<div id="outline-container-orgfee1093" class="outline-2">
<h2 id="orgfee1093">图的遍历方法</h2>
<div class="outline-text-2" id="text-orgfee1093">
</div>
<div id="outline-container-ID-b57c3ec5-bb6e-4d6f-915a-47083b7e6ba4" class="outline-3">
<h3 id="ID-b57c3ec5-bb6e-4d6f-915a-47083b7e6ba4">深度优先遍历</h3>
<div class="outline-text-3" id="text-ID-b57c3ec5-bb6e-4d6f-915a-47083b7e6ba4">
<ol class="org-ol">
<li>在访问一个顶点时，将它标记为已访问</li>
<li>递归地访问它的所有没有标记的邻居顶点</li>
</ol>

<p>
优先搜索访问起始顶点 a，然后从顶点 a 的邻接表中选取一个未访问过的结点 b 进行访问，并从 b 开始继续进行深度优先搜索。这个过程会将 a 的邻接表中的当前位置保存在一个栈中，当最终搜索到一个顶点 z，且 z 的邻接表中的结点全部被访问过时，就从这个栈中取出一个顶点，并按照上述方法处理该顶点的邻接表。在此搜索过程中，已经访问过的顶点不再被访问，而未被访问的顶点被访问且存入栈。当栈为空时，搜索就结束了。这些过程可以很容易使用递归来实现。最坏时间复杂度为 \(O(n+2e)\)
</p>


<figure id="org19fa4b3">
<img src="../images/data_structure_graph_depth_first_traversal_1.png" alt="data_structure_graph_depth_first_traversal_1.png">

</figure>


<ul class="org-ul">
<li>参考代码</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Dfs</span>(<span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span> ,<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span>) {
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>;
    printf(<span style="color: #008000;">"%d -&gt; "</span> ,v);
    visited[v] = <span style="color: #D0372D;">1</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span> ;i &lt;= n &amp;&amp; G[v][i] == <span style="color: #D0372D;">0</span>;i++)
        ;
    <span style="color: #0000FF;">for</span> (; i &lt;= n; i++)
        <span style="color: #0000FF;">if</span>(visited[i] == <span style="color: #D0372D;">0</span>)
            Dfs(G, i);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-ID-cf710117-1489-43c3-b428-51bce5e2a25c" class="outline-3">
<h3 id="ID-cf710117-1489-43c3-b428-51bce5e2a25c">广度优先遍历</h3>
<div class="outline-text-3" id="text-ID-cf710117-1489-43c3-b428-51bce5e2a25c">
<ol class="org-ol">
<li>取队列中的下一个顶点 a 并标记它</li>
<li>将和 a 相邻的所有为被标记过的顶点加入队列</li>
</ol>

<p>
从访问起始顶点 a 开始，并把 a 标记为已访问，然后，访问 a 的邻接表中的每一个顶点。在访问过 a 的邻接表中所有顶点后，访问与 a 的邻接表中的第一个顶点相邻，且未被访问过的所有顶点。这样就需要一个队列，把当前访问的顶点保存在这个队列中，在当前顶点的邻接表中的有顶点被访问过时，从队列中取出一个顶点，然后访问该顶点的邻接表中的所有顶点。在此搜索过程中，未被访问的顶点被访问，且存入队列，已经访问过的顶点不再被访问。当队列为空时，搜索就结束了。时间复杂度量级为 \(O(n^2)\)
</p>

<figure id="orgeecf205">
<img src="../images/data_structure_graph_breadth_first_traversal_1.png" alt="data_structure_graph_breadth_first_traversal_1.png">

</figure>


<ul class="org-ul">
<li>参考代码</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Bfs</span>(<span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>, <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span>) {
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>;
    <span style="color: #6434A3;">Queue</span> *<span style="color: #BA36A5;">Q</span> = (<span style="color: #6434A3;">Queue</span> *)malloc(<span style="color: #0000FF;">sizeof</span>(Queue));
    Initqueue(Q);
    printf(<span style="color: #008000;">"%d -&gt;"</span> ,v);
    visited[v] = <span style="color: #D0372D;">1</span>;
    enqueue(Q, v);
    <span style="color: #0000FF;">for</span> (; !quempty(Q); ) {
        v = dequeue(Q);
        <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>;i &lt;= n; i++) {
            <span style="color: #0000FF;">if</span> (visited[i] == <span style="color: #D0372D;">0</span> &amp;&amp; G[v][i] == <span style="color: #D0372D;">1</span>) {
                printf(<span style="color: #008000;">"%d -&gt;"</span>, i);
                visited[i] = <span style="color: #D0372D;">1</span>;
                enqueue(Q, i);
            }
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-ID-7827e4bf-f416-4549-b6b1-fdf83440f006" class="outline-3">
<h3 id="ID-7827e4bf-f416-4549-b6b1-fdf83440f006">拓扑排序</h3>
<div class="outline-text-3" id="text-ID-7827e4bf-f416-4549-b6b1-fdf83440f006">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">GNode</span> {
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Cnt</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#35745;&#25968;</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Tag</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#26631;&#31614;</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Vertex</span>;
    <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">GNode</span> *<span style="color: #BA36A5;">Link</span>;
} <span style="color: #6434A3;">GNode</span>;

<span style="color: #0000FF;">typedef</span> <span style="color: #6434A3;">GNode</span> <span style="color: #6434A3;">Graph</span>[MAX];

<span style="color: #6434A3;">void</span> <span style="color: #006699;">Topsort</span>(<span style="color: #6434A3;">Graph</span> <span style="color: #BA36A5;">G</span> ,<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">n</span>) {
    <span style="color: #6434A3;">GNode</span> *<span style="color: #BA36A5;">p</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>, <span style="color: #BA36A5;">k</span>, <span style="color: #BA36A5;">top</span> =- <span style="color: #D0372D;">1</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span> ;i &lt;= n; i++) {
        <span style="color: #0000FF;">if</span>(G[i].Cnt == <span style="color: #D0372D;">0</span>) {
            G[i].Cnt == top;
            top = i;
        }
    }
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span> ;i &lt;= n; i++) {
        <span style="color: #0000FF;">if</span> (top == -<span style="color: #D0372D;">1</span>) ;
        <span style="color: #0000FF;">else</span> {
            j = top;
            top = G[top].Cnt;
            printf(<span style="color: #008000;">"%d -&gt;"</span>,j);
            <span style="color: #0000FF;">for</span> (p = G[j].Link; p; p = p-&gt;Link) {
                k = p-&gt;Vertex;
                G[k].Cnt--;
                <span style="color: #0000FF;">if</span> (G[k].Cnt == <span style="color: #D0372D;">0</span>) {
                    G[k].Cnt = top;
                    top = k;
                }
            }
        }
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<a href="https://beian.miit.gov.cn" target="_blank">湘ICP证019014083号</a>
</div>
</body>
</html>
