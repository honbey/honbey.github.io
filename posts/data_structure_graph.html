<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-08-25 Thu 21:34 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>图</title>
<meta name="author" content="Honbey Zhang" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="../resources/orgmode.css" type="text/css"/>
                     <link rel="stylesheet" href="../resources/style.css" type="text/css"/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">图</h1>
</header><p>
图片来源于图书馆借的《算法（第 4 版）》一书，为了加深印象，对照书的图用 visio 画了一遍。
</p>

<div id="outline-container-org42b9be7" class="outline-2">
<h2 id="org42b9be7">图的表示法</h2>
<div class="outline-text-2" id="text-org42b9be7">
</div>
<div id="outline-container-org435007b" class="outline-3">
<h3 id="org435007b">邻接矩阵表示法</h3>
<div class="outline-text-3" id="text-org435007b">
<p>
对于任意图（设其顶点个数为 n），其邻接矩阵是一个 n×n 的二维数组，若 (0, 1) 是 G 的一条边，则其邻接矩阵 a[0][1] =1，若不是，则 a[0][1] = 0 。而且无向图的邻接矩阵一定是对称的。无向图的邻接矩阵只需存储其上三角或者其上三角部分。
</p>

<p>
对于一个有向图，顶点 i 所对应的 <b>行中的数字之和等于顶点 i 的出度</b> ，对应的 <b>列中的数字之和等于顶点 i 的入度</b> 。
</p>

<figure id="org59584f4">
<img src="../images/data_structure_graph_adjoin_matrix_1.png" alt="data_structure_graph_adjoin_matrix_1.png">

</figure>
</div>
</div>

<div id="outline-container-orgdc71483" class="outline-3">
<h3 id="orgdc71483">邻接表表示法</h3>
<div class="outline-text-3" id="text-orgdc71483">
<p>
对于有 n 个结点，e 条边的无向图，采用邻接表存储表示需要存储 <b>n 个头结点和 2e 个表结点</b> ，每个结点有两个域。同时，对于有 n 个结点，e 条边的无向图，可以在 \(O(n+e)\)  时间内确定无向图中边的总数。而对于有向图，通过对某个顶点的链表中的结点计数，可以得到该顶点的出度，但是对于该顶点的入度很难确定
</p>

<figure id="orgbb5cddd">
<img src="../images/data_structure_graph_adjoin_table_1.png" alt="data_structure_graph_adjoin_table_1.png">

</figure>
</div>
</div>

<div id="outline-container-org880364a" class="outline-3">
<h3 id="org880364a">邻接矩阵与邻接表相互转换</h3>
<div class="outline-text-3" id="text-org880364a">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Trans_MtoL</span><span style="color: #707183;">(</span><span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>, <span style="color: #6434A3;">Lgraph</span> <span style="color: #BA36A5;">Gl</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #6434A3;">Vnode</span> *<span style="color: #BA36A5;">p</span>, *<span style="color: #BA36A5;">q</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">e</span>, <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++<span style="color: #7388D6;">)</span> <span style="color: #7388D6;">{</span>
        Gl<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.data = i;
        Gl<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.next = <span style="color: #D0372D;">NULL</span>;
    <span style="color: #7388D6;">}</span>
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++<span style="color: #7388D6;">)</span> <span style="color: #7388D6;">{</span>
        <span style="color: #0000FF;">for</span> <span style="color: #909183;">(</span>j = i+<span style="color: #D0372D;">1</span>;j &lt;= n &amp;&amp; G<span style="color: #709870;">[</span>i<span style="color: #709870;">][</span>j<span style="color: #709870;">]</span> == <span style="color: #D0372D;">1</span>; j++<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            p = <span style="color: #709870;">(</span><span style="color: #6434A3;">Vnode</span> *<span style="color: #709870;">)</span>malloc<span style="color: #709870;">(</span><span style="color: #0000FF;">sizeof</span><span style="color: #707183;">(</span>Vnode<span style="color: #707183;">)</span><span style="color: #709870;">)</span>;
            p-&gt;data = i;
            p-&gt;next = Gl<span style="color: #709870;">[</span>j<span style="color: #709870;">]</span>.next;
            Gl<span style="color: #709870;">[</span>j<span style="color: #709870;">]</span>.next = p;
            q = <span style="color: #709870;">(</span><span style="color: #6434A3;">Vnode</span> *<span style="color: #709870;">)</span>malloc<span style="color: #709870;">(</span><span style="color: #0000FF;">sizeof</span><span style="color: #707183;">(</span>Vnode<span style="color: #707183;">)</span><span style="color: #709870;">)</span>;
            q-&gt;data = j;
            q-&gt;next = Gl<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.next;
            Gl<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.next = q;
        <span style="color: #909183;">}</span>
    <span style="color: #7388D6;">}</span>
    printf<span style="color: #7388D6;">(</span><span style="color: #008000;">"&#37051;&#25509;&#30697;&#38453;&#34920;&#31034;&#22914;&#19979;&#65306;\n"</span><span style="color: #7388D6;">)</span>;
    Output_mg<span style="color: #7388D6;">(</span>G<span style="color: #7388D6;">)</span>;
    printf<span style="color: #7388D6;">(</span><span style="color: #008000;">"\n &#37051;&#25509;&#34920;&#34920;&#31034;&#22914;&#19979; &#65306;"</span><span style="color: #7388D6;">)</span>;
    Output_L<span style="color: #7388D6;">(</span>Gl<span style="color: #7388D6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #6434A3;">void</span> <span style="color: #006699;">Trans_LtoM</span><span style="color: #707183;">(</span><span style="color: #6434A3;">Lgraph</span> <span style="color: #BA36A5;">Gl</span>, <span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #6434A3;">Vnode</span> *<span style="color: #BA36A5;">p</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++<span style="color: #7388D6;">)</span>
            <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>j = <span style="color: #D0372D;">1</span>; j &lt;= n; j++<span style="color: #7388D6;">)</span>
                G<span style="color: #7388D6;">[</span>i<span style="color: #7388D6;">][</span>j<span style="color: #7388D6;">]</span> = <span style="color: #D0372D;">0</span>;
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>i = <span style="color: #D0372D;">2</span>;i &lt;= n; i++<span style="color: #7388D6;">)</span> <span style="color: #7388D6;">{</span>
        p = Gl<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span>.next;
        <span style="color: #0000FF;">while</span> <span style="color: #909183;">(</span>p != <span style="color: #D0372D;">NULL</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            j = p-&gt;data;
            G<span style="color: #709870;">[</span>i<span style="color: #709870;">][</span>j<span style="color: #709870;">]</span> = <span style="color: #D0372D;">1</span>;
            G<span style="color: #709870;">[</span>j<span style="color: #709870;">][</span>i<span style="color: #709870;">]</span> = <span style="color: #D0372D;">1</span>;
            p = p-&gt;next;
        <span style="color: #909183;">}</span>
    <span style="color: #7388D6;">}</span>
    printf<span style="color: #7388D6;">(</span><span style="color: #008000;">" &#37051;&#25509;&#34920;&#34920;&#31034;&#22914;&#19979; &#65306;\n"</span><span style="color: #7388D6;">)</span>;
    Output_L<span style="color: #7388D6;">(</span>Gl<span style="color: #7388D6;">)</span>;
    printf<span style="color: #7388D6;">(</span><span style="color: #008000;">"\n&#37051;&#25509;&#30697;&#38453;&#34920;&#31034;&#22914;&#19979;&#65306;"</span><span style="color: #7388D6;">)</span>;
    Output_mg<span style="color: #7388D6;">(</span>G<span style="color: #7388D6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a78195" class="outline-3">
<h3 id="org8a78195">其他表示法</h3>
<div class="outline-text-3" id="text-org8a78195">

<figure id="org684ef01">
<img src="../images/data_structure_graph_mixed_expression_1.png" alt="data_structure_graph_mixed_expression_1.png">

</figure>
</div>
</div>
</div>

<div id="outline-container-org8953358" class="outline-2">
<h2 id="org8953358">图的遍历方法</h2>
<div class="outline-text-2" id="text-org8953358">
</div>
<div id="outline-container-ID-b57c3ec5-bb6e-4d6f-915a-47083b7e6ba4" class="outline-3">
<h3 id="ID-b57c3ec5-bb6e-4d6f-915a-47083b7e6ba4">深度优先遍历</h3>
<div class="outline-text-3" id="text-org4d16aae">
<ol class="org-ol">
<li>在访问一个顶点时，将它标记为已访问</li>
<li>递归地访问它的所有没有标记的邻居顶点</li>
</ol>

<p>
优先搜索访问起始顶点 a，然后从顶点 a 的邻接表中选取一个未访问过的结点 b 进行访问，并从 b 开始继续进行深度优先搜索。这个过程会将 a 的邻接表中的当前位置保存在一个栈中，当最终搜索到一个顶点 z，且 z 的邻接表中的结点全部被访问过时，就从这个栈中取出一个顶点，并按照上述方法处理该顶点的邻接表。在此搜索过程中，已经访问过的顶点不再被访问，而未被访问的顶点被访问且存入栈。当栈为空时，搜索就结束了。这些过程可以很容易使用递归来实现。最坏时间复杂度为 \(O(n+2e)\)
</p>


<figure id="org0ceab14">
<img src="../images/data_structure_graph_depth_first_traversal_1.png" alt="data_structure_graph_depth_first_traversal_1.png">

</figure>


<ul class="org-ul">
<li>参考代码</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Dfs</span><span style="color: #707183;">(</span><span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span> ,<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>;
    printf<span style="color: #7388D6;">(</span><span style="color: #008000;">"%d -&gt; "</span> ,v<span style="color: #7388D6;">)</span>;
    visited<span style="color: #7388D6;">[</span>v<span style="color: #7388D6;">]</span> = <span style="color: #D0372D;">1</span>;
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>i = <span style="color: #D0372D;">1</span> ;i &lt;= n &amp;&amp; G<span style="color: #909183;">[</span>v<span style="color: #909183;">][</span>i<span style="color: #909183;">]</span> == <span style="color: #D0372D;">0</span>;i++<span style="color: #7388D6;">)</span>
        ;
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>; i &lt;= n; i++<span style="color: #7388D6;">)</span>
        <span style="color: #0000FF;">if</span><span style="color: #7388D6;">(</span>visited<span style="color: #909183;">[</span>i<span style="color: #909183;">]</span> == <span style="color: #D0372D;">0</span><span style="color: #7388D6;">)</span>
            Dfs<span style="color: #7388D6;">(</span>G, i<span style="color: #7388D6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-ID-cf710117-1489-43c3-b428-51bce5e2a25c" class="outline-3">
<h3 id="ID-cf710117-1489-43c3-b428-51bce5e2a25c">广度优先遍历</h3>
<div class="outline-text-3" id="text-orge3c2702">
<ol class="org-ol">
<li>取队列中的下一个顶点 a 并标记它</li>
<li>将和 a 相邻的所有为被标记过的顶点加入队列</li>
</ol>

<p>
从访问起始顶点 a 开始，并把 a 标记为已访问，然后，访问 a 的邻接表中的每一个顶点。在访问过 a 的邻接表中所有顶点后，访问与 a 的邻接表中的第一个顶点相邻，且未被访问过的所有顶点。这样就需要一个队列，把当前访问的顶点保存在这个队列中，在当前顶点的邻接表中的有顶点被访问过时，从队列中取出一个顶点，然后访问该顶点的邻接表中的所有顶点。在此搜索过程中，未被访问的顶点被访问，且存入队列，已经访问过的顶点不再被访问。当队列为空时，搜索就结束了。时间复杂度量级为 \(O(n^2)\)
</p>

<figure id="orgc21a90b">
<img src="../images/data_structure_graph_breadth_first_traversal_1.png" alt="data_structure_graph_breadth_first_traversal_1.png">

</figure>


<ul class="org-ul">
<li>参考代码</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Bfs</span><span style="color: #707183;">(</span><span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>, <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>;
    <span style="color: #6434A3;">Queue</span> *<span style="color: #BA36A5;">Q</span> = <span style="color: #7388D6;">(</span><span style="color: #6434A3;">Queue</span> *<span style="color: #7388D6;">)</span>malloc<span style="color: #7388D6;">(</span><span style="color: #0000FF;">sizeof</span><span style="color: #909183;">(</span>Queue<span style="color: #909183;">)</span><span style="color: #7388D6;">)</span>;
    Initqueue<span style="color: #7388D6;">(</span>Q<span style="color: #7388D6;">)</span>;
    printf<span style="color: #7388D6;">(</span><span style="color: #008000;">"%d -&gt;"</span> ,v<span style="color: #7388D6;">)</span>;
    visited<span style="color: #7388D6;">[</span>v<span style="color: #7388D6;">]</span> = <span style="color: #D0372D;">1</span>;
    enqueue<span style="color: #7388D6;">(</span>Q, v<span style="color: #7388D6;">)</span>;
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>; !quempty<span style="color: #909183;">(</span>Q<span style="color: #909183;">)</span>; <span style="color: #7388D6;">)</span> <span style="color: #7388D6;">{</span>
        v = dequeue<span style="color: #909183;">(</span>Q<span style="color: #909183;">)</span>;
        <span style="color: #0000FF;">for</span> <span style="color: #909183;">(</span>i = <span style="color: #D0372D;">1</span>;i &lt;= n; i++<span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #0000FF;">if</span> <span style="color: #709870;">(</span>visited<span style="color: #707183;">[</span>i<span style="color: #707183;">]</span> == <span style="color: #D0372D;">0</span> &amp;&amp; G<span style="color: #707183;">[</span>v<span style="color: #707183;">][</span>i<span style="color: #707183;">]</span> == <span style="color: #D0372D;">1</span><span style="color: #709870;">)</span> <span style="color: #709870;">{</span>
                printf<span style="color: #707183;">(</span><span style="color: #008000;">"%d -&gt;"</span>, i<span style="color: #707183;">)</span>;
                visited<span style="color: #707183;">[</span>i<span style="color: #707183;">]</span> = <span style="color: #D0372D;">1</span>;
                enqueue<span style="color: #707183;">(</span>Q, i<span style="color: #707183;">)</span>;
            <span style="color: #709870;">}</span>
        <span style="color: #909183;">}</span>
    <span style="color: #7388D6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-ID-7827e4bf-f416-4549-b6b1-fdf83440f006" class="outline-3">
<h3 id="ID-7827e4bf-f416-4549-b6b1-fdf83440f006">拓扑排序</h3>
<div class="outline-text-3" id="text-org96a7c8d">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">GNode</span> <span style="color: #707183;">{</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Cnt</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#35745;&#25968;</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Tag</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#26631;&#31614;</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Vertex</span>;
    <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">GNode</span> *<span style="color: #BA36A5;">Link</span>;
<span style="color: #707183;">}</span> <span style="color: #6434A3;">GNode</span>;

<span style="color: #0000FF;">typedef</span> <span style="color: #6434A3;">GNode</span> <span style="color: #6434A3;">Graph</span><span style="color: #707183;">[</span><span style="color: #D0372D;">MAX</span><span style="color: #707183;">]</span>;

<span style="color: #6434A3;">void</span> <span style="color: #006699;">Topsort</span><span style="color: #707183;">(</span><span style="color: #6434A3;">Graph</span> <span style="color: #BA36A5;">G</span> ,<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">n</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #6434A3;">GNode</span> *<span style="color: #BA36A5;">p</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>, <span style="color: #BA36A5;">k</span>, <span style="color: #BA36A5;">top</span> =- <span style="color: #D0372D;">1</span>;
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>i = <span style="color: #D0372D;">1</span> ;i &lt;= n; i++<span style="color: #7388D6;">)</span> <span style="color: #7388D6;">{</span>
        <span style="color: #0000FF;">if</span><span style="color: #909183;">(</span>G<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.Cnt == <span style="color: #D0372D;">0</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            G<span style="color: #709870;">[</span>i<span style="color: #709870;">]</span>.Cnt == top;
            top = i;
        <span style="color: #909183;">}</span>
    <span style="color: #7388D6;">}</span>
    <span style="color: #0000FF;">for</span> <span style="color: #7388D6;">(</span>i = <span style="color: #D0372D;">1</span> ;i &lt;= n; i++<span style="color: #7388D6;">)</span> <span style="color: #7388D6;">{</span>
        <span style="color: #0000FF;">if</span> <span style="color: #909183;">(</span>top == -<span style="color: #D0372D;">1</span><span style="color: #909183;">)</span> ;
        <span style="color: #0000FF;">else</span> <span style="color: #909183;">{</span>
            j = top;
            top = G<span style="color: #709870;">[</span>top<span style="color: #709870;">]</span>.Cnt;
            printf<span style="color: #709870;">(</span><span style="color: #008000;">"%d -&gt;"</span>,j<span style="color: #709870;">)</span>;
            <span style="color: #0000FF;">for</span> <span style="color: #709870;">(</span>p = G<span style="color: #707183;">[</span>j<span style="color: #707183;">]</span>.Link; p; p = p-&gt;Link<span style="color: #709870;">)</span> <span style="color: #709870;">{</span>
                k = p-&gt;Vertex;
                G<span style="color: #707183;">[</span>k<span style="color: #707183;">]</span>.Cnt--;
                <span style="color: #0000FF;">if</span> <span style="color: #707183;">(</span>G<span style="color: #7388D6;">[</span>k<span style="color: #7388D6;">]</span>.Cnt == <span style="color: #D0372D;">0</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
                    G<span style="color: #7388D6;">[</span>k<span style="color: #7388D6;">]</span>.Cnt = top;
                    top = k;
                <span style="color: #707183;">}</span>
            <span style="color: #709870;">}</span>
        <span style="color: #909183;">}</span>
    <span style="color: #7388D6;">}</span>
<span style="color: #707183;">}</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<a href="https://beian.miit.gov.cn" target="_blank">湘ICP证019014083号</a>
</div>
</body>
</html>
