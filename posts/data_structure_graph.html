<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-12-03 Sun 16:50 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>图</title>
<meta name="author" content="Honbey Zhang" />
<meta name="generator" content="Org Mode" />

                     <link rel="stylesheet" href="../resources/src/bigblow_theme/css/htmlize.css" type="text/css"/>
                     <link rel="stylesheet" href="../resources/src/bigblow_theme/css/bigblow.css" type="text/css"/>
                     <link rel="stylesheet" href="../resources/src/bigblow_theme/css/hideshow.css" type="text/css"/>
                     <script type="text/javascript" src="../resources/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
                     <script type="text/javascript" src="../resources/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
                     <script type="text/javascript" src="../resources/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
                     <script type="text/javascript" src="../resources/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
                     <script type="text/javascript" src="../resources/src/bigblow_theme/js/bigblow.js"></script>
                     <script type="text/javascript" src="../resources/src/bigblow_theme/js/hideshow.js"></script>
                     <script type="text/javascript" src="../resources/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '%MULTLINEWIDTH'
      },
      tags: '%TAGS',
      tagSide: '%TAGSIDE',
      tagIndent: '%TAGINDENT'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '2em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '2em'
    },
    output: {
      font: '%FONT',
      displayOverflow: '%OVERFLOW'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">图</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org710dec0">图的表示法</a>
<ul>
<li><a href="#orgd8aae86">邻接矩阵表示法</a></li>
<li><a href="#org3c8de70">邻接表表示法</a></li>
<li><a href="#orgce81afb">邻接矩阵与邻接表相互转换</a></li>
<li><a href="#org1afd29e">其他表示法</a></li>
</ul>
</li>
<li><a href="#org5f18765">图的遍历方法</a>
<ul>
<li><a href="#org8abdab8">深度优先遍历</a></li>
<li><a href="#org4b2885b">广度优先遍历</a></li>
<li><a href="#orgeebad5c">拓扑排序</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
图片来源于图书馆借的《算法（第 4 版）》一书，为了加深印象，对照书的图用 visio 画了一遍。
</p>
<div id="outline-container-org710dec0" class="outline-2">
<h2 id="org710dec0">图的表示法</h2>
<div class="outline-text-2" id="text-org710dec0">
</div>
<div id="outline-container-orgd8aae86" class="outline-3">
<h3 id="orgd8aae86">邻接矩阵表示法</h3>
<div class="outline-text-3" id="text-orgd8aae86">
<p>
对于任意图（设其顶点个数为 n），其邻接矩阵是一个 n×n 的二维数组，若 (0, 1) 是 G 的一条边，则其邻接矩阵 a[0][1] =1，若不是，则 a[0][1] = 0 。而且无向图的邻接矩阵一定是对称的。无向图的邻接矩阵只需存储其上三角或者其上三角部分。
</p>

<p>
对于一个有向图，顶点 i 所对应的 <b>行中的数字之和等于顶点 i 的出度</b> ，对应的 <b>列中的数字之和等于顶点 i 的入度</b> 。
</p>
</div>
</div>
<div id="outline-container-org3c8de70" class="outline-3">
<h3 id="org3c8de70">邻接表表示法</h3>
<div class="outline-text-3" id="text-org3c8de70">
<p>
对于有 n 个结点，e 条边的无向图，采用邻接表存储表示需要存储 <b>n 个头结点和 2e 个表结点</b> ，每个结点有两个域。同时，对于有 n 个结点，e 条边的无向图，可以在 \(O(n+e)\)  时间内确定无向图中边的总数。而对于有向图，通过对某个顶点的链表中的结点计数，可以得到该顶点的出度，但是对于该顶点的入度很难确定
</p>

<figure id="org66dee98">
<img src="./../images/data_structure_graph_adjoin_table_1.png" alt="data_structure_graph_adjoin_table_1.png">

</figure>
</div>
</div>
<div id="outline-container-orgce81afb" class="outline-3">
<h3 id="orgce81afb">邻接矩阵与邻接表相互转换</h3>
<div class="outline-text-3" id="text-orgce81afb">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Trans_MtoL</span>(<span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>, <span style="color: #6434A3;">Lgraph</span> <span style="color: #BA36A5;">Gl</span>) {
    <span style="color: #6434A3;">Vnode</span> *<span style="color: #BA36A5;">p</span>, *<span style="color: #BA36A5;">q</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">e</span>, <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++) {
        Gl[i].data = i;
        Gl[i].next = <span style="color: #D0372D;">NULL</span>;
    }
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++) {
        <span style="color: #0000FF;">for</span> (j = i+<span style="color: #D0372D;">1</span>;j &lt;= n &amp;&amp; G[i][j] == <span style="color: #D0372D;">1</span>; j++) {
            p = (<span style="color: #6434A3;">Vnode</span> *)malloc(<span style="color: #0000FF;">sizeof</span>(Vnode));
            p-&gt;data = i;
            p-&gt;next = Gl[j].next;
            Gl[j].next = p;
            q = (<span style="color: #6434A3;">Vnode</span> *)malloc(<span style="color: #0000FF;">sizeof</span>(Vnode));
            q-&gt;data = j;
            q-&gt;next = Gl[i].next;
            Gl[i].next = q;
        }
    }
    printf(<span style="color: #008000;">"&#37051;&#25509;&#30697;&#38453;&#34920;&#31034;&#22914;&#19979;&#65306;\n"</span>);
    Output_mg(G);
    printf(<span style="color: #008000;">"\n &#37051;&#25509;&#34920;&#34920;&#31034;&#22914;&#19979; &#65306;"</span>);
    Output_L(Gl);
}

<span style="color: #6434A3;">void</span> <span style="color: #006699;">Trans_LtoM</span>(<span style="color: #6434A3;">Lgraph</span> <span style="color: #BA36A5;">Gl</span>, <span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>) {
    <span style="color: #6434A3;">Vnode</span> *<span style="color: #BA36A5;">p</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>; i &lt;= n; i++)
            <span style="color: #0000FF;">for</span> (j = <span style="color: #D0372D;">1</span>; j &lt;= n; j++)
                G[i][j] = <span style="color: #D0372D;">0</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">2</span>;i &lt;= n; i++) {
        p = Gl[i].next;
        <span style="color: #0000FF;">while</span> (p != <span style="color: #D0372D;">NULL</span>) {
            j = p-&gt;data;
            G[i][j] = <span style="color: #D0372D;">1</span>;
            G[j][i] = <span style="color: #D0372D;">1</span>;
            p = p-&gt;next;
        }
    }
    printf(<span style="color: #008000;">" &#37051;&#25509;&#34920;&#34920;&#31034;&#22914;&#19979; &#65306;\n"</span>);
    Output_L(Gl);
    printf(<span style="color: #008000;">"\n&#37051;&#25509;&#30697;&#38453;&#34920;&#31034;&#22914;&#19979;&#65306;"</span>);
    Output_mg(G);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org1afd29e" class="outline-3">
<h3 id="org1afd29e">其他表示法</h3>
<div class="outline-text-3" id="text-org1afd29e">

<figure id="org98cb92e">
<img src="./../images/data_structure_graph_mixed_expression_1.png" alt="data_structure_graph_mixed_expression_1.png">

</figure>
</div>
</div>
</div>
<div id="outline-container-org5f18765" class="outline-2">
<h2 id="org5f18765">图的遍历方法</h2>
<div class="outline-text-2" id="text-org5f18765">
</div>
<div id="outline-container-org8abdab8" class="outline-3">
<h3 id="org8abdab8">深度优先遍历</h3>
<div class="outline-text-3" id="text-org8abdab8">
<ol class="org-ol">
<li>在访问一个顶点时，将它标记为已访问</li>
<li>递归地访问它的所有没有标记的邻居顶点</li>
</ol>

<p>
优先搜索访问起始顶点 a，然后从顶点 a 的邻接表中选取一个未访问过的结点 b 进行访问，并从 b 开始继续进行深度优先搜索。这个过程会将 a 的邻接表中的当前位置保存在一个栈中，当最终搜索到一个顶点 z，且 z 的邻接表中的结点全部被访问过时，就从这个栈中取出一个顶点，并按照上述方法处理该顶点的邻接表。在此搜索过程中，已经访问过的顶点不再被访问，而未被访问的顶点被访问且存入栈。当栈为空时，搜索就结束了。这些过程可以很容易使用递归来实现。最坏时间复杂度为 \(O(n+2e)\)
</p>


<figure id="org8ae57a1">
<img src="./../images/data_structure_graph_depth_first_traversal_1.png" alt="data_structure_graph_depth_first_traversal_1.png">

</figure>


<ul class="org-ul">
<li>参考代码</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Dfs</span>(<span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span> ,<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span>) {
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>;
    printf(<span style="color: #008000;">"%d -&gt; "</span> ,v);
    visited[v] = <span style="color: #D0372D;">1</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span> ;i &lt;= n &amp;&amp; G[v][i] == <span style="color: #D0372D;">0</span>;i++)
        ;
    <span style="color: #0000FF;">for</span> (; i &lt;= n; i++)
        <span style="color: #0000FF;">if</span>(visited[i] == <span style="color: #D0372D;">0</span>)
            Dfs(G, i);
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org4b2885b" class="outline-3">
<h3 id="org4b2885b">广度优先遍历</h3>
<div class="outline-text-3" id="text-org4b2885b">
<ol class="org-ol">
<li>取队列中的下一个顶点 a 并标记它</li>
<li>将和 a 相邻的所有为被标记过的顶点加入队列</li>
</ol>

<p>
从访问起始顶点 a 开始，并把 a 标记为已访问，然后，访问 a 的邻接表中的每一个顶点。在访问过 a 的邻接表中所有顶点后，访问与 a 的邻接表中的第一个顶点相邻，且未被访问过的所有顶点。这样就需要一个队列，把当前访问的顶点保存在这个队列中，在当前顶点的邻接表中的有顶点被访问过时，从队列中取出一个顶点，然后访问该顶点的邻接表中的所有顶点。在此搜索过程中，未被访问的顶点被访问，且存入队列，已经访问过的顶点不再被访问。当队列为空时，搜索就结束了。时间复杂度量级为 \(O(n^2)\)
</p>

<figure id="org5364c58">
<img src="./../images/data_structure_graph_breadth_first_traversal_1.png" alt="data_structure_graph_breadth_first_traversal_1.png">

</figure>


<ul class="org-ul">
<li>参考代码</li>
</ul>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">void</span> <span style="color: #006699;">Bfs</span>(<span style="color: #6434A3;">Mgraph</span> <span style="color: #BA36A5;">G</span>, <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">v</span>) {
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>;
    <span style="color: #6434A3;">Queue</span> *<span style="color: #BA36A5;">Q</span> = (<span style="color: #6434A3;">Queue</span> *)malloc(<span style="color: #0000FF;">sizeof</span>(Queue));
    Initqueue(Q);
    printf(<span style="color: #008000;">"%d -&gt;"</span> ,v);
    visited[v] = <span style="color: #D0372D;">1</span>;
    enqueue(Q, v);
    <span style="color: #0000FF;">for</span> (; !quempty(Q); ) {
        v = dequeue(Q);
        <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span>;i &lt;= n; i++) {
            <span style="color: #0000FF;">if</span> (visited[i] == <span style="color: #D0372D;">0</span> &amp;&amp; G[v][i] == <span style="color: #D0372D;">1</span>) {
                printf(<span style="color: #008000;">"%d -&gt;"</span>, i);
                visited[i] = <span style="color: #D0372D;">1</span>;
                enqueue(Q, i);
            }
        }
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgeebad5c" class="outline-3">
<h3 id="orgeebad5c">拓扑排序</h3>
<div class="outline-text-3" id="text-orgeebad5c">
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">typedef</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">GNode</span> {
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Cnt</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#35745;&#25968;</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Tag</span>; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">&#26631;&#31614;</span>
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">Vertex</span>;
    <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">GNode</span> *<span style="color: #BA36A5;">Link</span>;
} <span style="color: #6434A3;">GNode</span>;

<span style="color: #0000FF;">typedef</span> <span style="color: #6434A3;">GNode</span> <span style="color: #6434A3;">Graph</span>[MAX];

<span style="color: #6434A3;">void</span> <span style="color: #006699;">Topsort</span>(<span style="color: #6434A3;">Graph</span> <span style="color: #BA36A5;">G</span> ,<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">n</span>) {
    <span style="color: #6434A3;">GNode</span> *<span style="color: #BA36A5;">p</span>;
    <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>, <span style="color: #BA36A5;">k</span>, <span style="color: #BA36A5;">top</span> =- <span style="color: #D0372D;">1</span>;
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span> ;i &lt;= n; i++) {
        <span style="color: #0000FF;">if</span>(G[i].Cnt == <span style="color: #D0372D;">0</span>) {
            G[i].Cnt == top;
            top = i;
        }
    }
    <span style="color: #0000FF;">for</span> (i = <span style="color: #D0372D;">1</span> ;i &lt;= n; i++) {
        <span style="color: #0000FF;">if</span> (top == -<span style="color: #D0372D;">1</span>) ;
        <span style="color: #0000FF;">else</span> {
            j = top;
            top = G[top].Cnt;
            printf(<span style="color: #008000;">"%d -&gt;"</span>,j);
            <span style="color: #0000FF;">for</span> (p = G[j].Link; p; p = p-&gt;Link) {
                k = p-&gt;Vertex;
                G[k].Cnt--;
                <span style="color: #0000FF;">if</span> (G[k].Cnt == <span style="color: #D0372D;">0</span>) {
                    G[k].Cnt = top;
                    top = k;
                }
            }
        }
    }
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

                     Theme
                     <a href="https://github.com/fniessen/org-html-themes" target="_blank">bigblow</a>
                     by
                     <a href="https://github.com/fniessen" target="_blank">fniessen</a>
                     <br>
                     <a href="https://beian.miit.gov.cn" target="_blank">湘ICP证019014083号</a>
</div>
</body>
</html>