<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-09-08 Thu 01:44 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lua 语言基础</title>
<meta name="author" content="Honbey Zhang" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="../resources/orgmode.css" type="text/css"/>
                     <link rel="stylesheet" href="../resources/style.css" type="text/css"/>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">Lua 语言基础</h1>
</header>
<div id="outline-container-orgc5b579c" class="outline-2">
<h2 id="orgc5b579c">Lua</h2>
<div class="outline-text-2" id="text-orgc5b579c">
<p>
TOC:
</p>
<ul class="org-ul">
<li><a href="#ID-9380063e-36ea-4175-80ec-8d143dc2c749">Lua 数据类型</a></li>
<li><a href="#ID-2432f320-c6ae-44a4-a886-d801b8674f94">Lua 函数</a></li>
<li><a href="#ID-09c26f8e-676d-4c1a-b392-0a4fe169411d">Lua 字符串</a></li>
<li><a href="#ID-797f8520-7bfd-42d3-81e8-600c8f05a2df">Lua 数组</a></li>
<li><a href="#ID-36033706-44ec-40c9-9f1f-9e52517c7ca4">Lua 迭代器</a></li>
<li><a href="#ID-66bd9f20-0480-4713-8800-fad492574a46">Lua 表 table</a></li>
<li><a href="#ID-83e40e27-ad20-4167-9486-d244c010cfc4">Lua 元表 Metatable</a></li>
<li><a href="#ID-e0a477d7-479c-4aa4-9d00-f7f2b9407be3">Lua 模块与包</a></li>
<li><a href="#ID-1ef86fa1-bec0-428b-b1de-02a53a21fa8e">Lua 协同程序 coroutine</a></li>
<li><a href="#ID-9f98a4a7-80be-4291-82ea-f383031c724b">Lua I/O</a></li>
<li><a href="#ID-56dfdc61-5be3-40b1-8825-c2523bb2f006">Lua 错误处理</a></li>
<li><a href="#ID-edbcb6f6-313a-4e7a-845d-e70a8184c73c">Lua 垃圾回收</a></li>
</ul>

<p>
应用：
</p>
<ul class="org-ul">
<li><a href="install_lua_resty_waf.html#ID-f30d98cd-d9d7-480b-987b-451979c1adb1">安装使用 lua-resty-waf</a></li>
</ul>

<p>
基于 C 的脚本语言。
</p>
</div>

<div id="outline-container-org9513ab6" class="outline-3">
<h3 id="org9513ab6">交互式</h3>
<div class="outline-text-3" id="text-org9513ab6">
<div class="org-src-container">
<pre class="src src-bash">lua
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">or</span>
lua -i
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b704b6" class="outline-3">
<h3 id="org1b704b6">注释</h3>
<div class="outline-text-3" id="text-org1b704b6">
<p>
特例：shebang <code>#~/usr/bin/env lua</code>
</p>

<p>
单行注释：
</p>
<div class="org-src-container">
<pre class="src src-lua">-- 注释
</pre>
</div>

<p>
多行注释：
</p>
<div class="org-src-container">
<pre class="src src-lua">--[[
  注释 [a]...
  注释
--]]
</pre>
</div>
</div>
</div>

<div id="outline-container-org69b8e3f" class="outline-3">
<h3 id="org69b8e3f">标示符</h3>
<div class="outline-text-3" id="text-org69b8e3f">
<p>
定义变量，以字母 <code>a-zA-Z</code> 或下划线 <code>_</code> 开头，后接数字、字母、下划线组成，不允许使用特殊字符如 <code>@, $, %</code> 来定义标示符，区分大小写
</p>
</div>
</div>

<div id="outline-container-org68dae5f" class="outline-3">
<h3 id="org68dae5f">Lua 关键字</h3>
<div class="outline-text-3" id="text-org68dae5f">
<pre class="example">
| and      | break | do    | else   |
| elseif   | end   | false | for    |
| function | if    | in    | local  |
| nil      | not   | or    | repeat |
| return   | then  | true  | until  |
| while    | goto  |       |        |
</pre>
</div>
</div>
<div id="outline-container-org8c1d8d2" class="outline-3">
<h3 id="org8c1d8d2">Lua 运算符</h3>
<div class="outline-text-3" id="text-org8c1d8d2">
<p>
算术运算符：
</p>
<ul class="org-ul">
<li>+ 加法</li>
<li>+ 减法</li>
<li>* 乘法</li>
<li>/ 除法</li>
<li>% 取余</li>
<li>^ 乘幂</li>
<li>- 负号</li>
</ul>

<p>
关系运算符：
</p>
<ul class="org-ul">
<li>== 等于</li>
<li>~= 不等于</li>
<li>&gt;</li>
<li>&lt;</li>
<li>&gt;=</li>
<li>&lt;=</li>
</ul>

<p>
逻辑运算符：
</p>
<ul class="org-ul">
<li>and 与</li>
<li>or  或</li>
<li>not 非</li>
</ul>

<p>
其他运算符：
</p>
<ul class="org-ul">
<li>.. 连接两个字符串</li>
<li>#  一元运算符，返回字符串或表的长度</li>
</ul>
</div>

<div id="outline-container-org767b0c7" class="outline-4">
<h4 id="org767b0c7">运算符优先级</h4>
<div class="outline-text-4" id="text-org767b0c7">
<pre class="example">
^
not  - (unary)
/    *         %
+    -
..
&lt;    &gt;        &lt;=  &gt;=  ~=  ==
and
or
</pre>

<p>
除了 <code>^</code> 和 <code>..</code> 外所有运算符都是左连接的
</p>
</div>
</div>
</div>

<div id="outline-container-orgc3b6f32" class="outline-3">
<h3 id="orgc3b6f32">Lua 变量</h3>
<div class="outline-text-3" id="text-orgc3b6f32">
<p>
lua 的变量默认都是全局变量，除非使用 local 进行声明
</p>

<p>
全局变量：默认情况下，变量总是认为是全局的，未初始化的全局变量的值为 <code>nil</code> 。
</p>

<p>
赋值：可对多个变量同时赋值，各元素用逗号 <code>,</code> 分隔，若变量个数大于值的个数，补 nil，反之忽略多余的值
</p>

<p>
索引：使用 <code>[]</code> 进行索引
</p>
</div>
</div>

<div id="outline-container-org75bc897" class="outline-3">
<h3 id="org75bc897">Lua 语法结构</h3>
<div class="outline-text-3" id="text-org75bc897">
</div>
<div id="outline-container-org76e2aa2" class="outline-4">
<h4 id="org76e2aa2">循环</h4>
<div class="outline-text-4" id="text-org76e2aa2">
<ul class="org-ul">
<li>while</li>
<li>for</li>
<li>repeat until</li>
</ul>

<p>
循环控制语句
</p>
<ul class="org-ul">
<li>break</li>
<li>goto</li>
</ul>

<div class="org-src-container">
<pre class="src src-lua">while (true)
do
  print("Hello")
end

goto Label
::Label::
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lua">for i=10, 1, -1 do
  print(i)
end
</pre>
</div>
</div>
</div>

<div id="outline-container-org17253b7" class="outline-4">
<h4 id="org17253b7">流程控制</h4>
<div class="outline-text-4" id="text-org17253b7">
<ul class="org-ul">
<li>if elseif else</li>
</ul>

<div class="org-src-container">
<pre class="src src-lua">if (f == 1)
then
  code
elseif
then
  code
else
  code
end
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-ID-9380063e-36ea-4175-80ec-8d143dc2c749" class="outline-2">
<h2 id="ID-9380063e-36ea-4175-80ec-8d143dc2c749">Lua 数据类型</h2>
<div class="outline-text-2" id="text-ID-9380063e-36ea-4175-80ec-8d143dc2c749">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">数据类型</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">nil</td>
<td class="org-left">标示无效值，逻辑判断为 false</td>
</tr>

<tr>
<td class="org-left">boolean</td>
<td class="org-left">布尔值，true / false</td>
</tr>

<tr>
<td class="org-left">number</td>
<td class="org-left">双精度实浮点数</td>
</tr>

<tr>
<td class="org-left">string</td>
<td class="org-left">单引号或双引号包裹的字符串</td>
</tr>

<tr>
<td class="org-left">function</td>
<td class="org-left">由 C 或 lua 编写的函数</td>
</tr>

<tr>
<td class="org-left">userdata</td>
<td class="org-left">任意存储在变量中的 C 数据结构</td>
</tr>

<tr>
<td class="org-left">thread</td>
<td class="org-left">标示执行的独立线程</td>
</tr>

<tr>
<td class="org-left">table</td>
<td class="org-left">关联数组 associative arrays, {}</td>
</tr>
</tbody>
</table>

<blockquote>
<p>
<b>nil 作比较时应该加上双引号</b>
</p>
</blockquote>
</div>
</div>

<div id="outline-container-ID-2432f320-c6ae-44a4-a886-d801b8674f94" class="outline-2">
<h2 id="ID-2432f320-c6ae-44a4-a886-d801b8674f94">Lua 函数</h2>
<div class="outline-text-2" id="text-ID-2432f320-c6ae-44a4-a886-d801b8674f94">
<div class="org-src-container">
<pre class="src src-lua">optional_function_scope function function_name( argument1, argument2, argument3..., argumentn)
  function_body
  return result_params_comma_separated
end
</pre>
</div>

<p>
optional<sub>function</sub><sub>scope</sub>: 指定全局还是局部，默认全局，使用 local 指定为局部
</p>
</div>

<div id="outline-container-org4552aa0" class="outline-3">
<h3 id="org4552aa0">可变参数</h3>
<div class="outline-text-3" id="text-org4552aa0">
<p>
在函数列表中使用三点 <code>...</code> 表示函数有可变的参数，在函数中使用 <code>{...}</code> 表示由所有变长参数构成的数组，也可使用 <code>select("#", ...)</code> 来获取可变参数的数量， <code>select(n, ...)</code> 返回从起点 n 开始到结束位置的所有参数列表，固定参数必须放在变长参数之前。
</p>
</div>
</div>
</div>


<div id="outline-container-ID-09c26f8e-676d-4c1a-b392-0a4fe169411d" class="outline-2">
<h2 id="ID-09c26f8e-676d-4c1a-b392-0a4fe169411d">Lua 字符串</h2>
<div class="outline-text-2" id="text-ID-09c26f8e-676d-4c1a-b392-0a4fe169411d">
<p>
表示方法：
</p>
<ul class="org-ul">
<li>单引号 <code>''</code></li>
<li>双引号 <code>""</code></li>
<li>双中括号 <code>[[]]</code></li>
</ul>

<p>
转义字符同 C 语言
</p>
</div>

<div id="outline-container-org99ea643" class="outline-3">
<h3 id="org99ea643">字符串方法</h3>
<div class="outline-text-3" id="text-org99ea643">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">string.upper(argument)</td>
<td class="org-left">将字符串全部转换为大写</td>
</tr>

<tr>
<td class="org-left">string.lower(argument)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">string.gsub(str, substr, replace, num)</td>
<td class="org-left">替换</td>
</tr>

<tr>
<td class="org-left">string.find(str, substr[, init, [end]])</td>
<td class="org-left">搜索</td>
</tr>

<tr>
<td class="org-left">string.reverse(argument)</td>
<td class="org-left">反转</td>
</tr>

<tr>
<td class="org-left">string.format(&#x2026;)</td>
<td class="org-left">返回一个类似 printf 的格式化字符串</td>
</tr>

<tr>
<td class="org-left">string.char(argument)</td>
<td class="org-left">将整型数字转为字符并连接</td>
</tr>

<tr>
<td class="org-left">string.byte(argument[, int])</td>
<td class="org-left">转换字符为整数值</td>
</tr>

<tr>
<td class="org-left">string.len(str)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">string.rep(str, n)</td>
<td class="org-left">返回 n 个 str 的拷贝</td>
</tr>

<tr>
<td class="org-left">..</td>
<td class="org-left">连接两个字符串</td>
</tr>

<tr>
<td class="org-left">string.gmatch(str, pattern)</td>
<td class="org-left">返回一个迭代器函数，调用这个函数返回相应子串，无则 nil</td>
</tr>

<tr>
<td class="org-left">string.match(str, pattern, init)</td>
<td class="org-left">查找符合条件的第一个匹配</td>
</tr>

<tr>
<td class="org-left">string.sub(str, init[, end])</td>
<td class="org-left">截取</td>
</tr>
</tbody>
</table>

<p>
<code>string.format(...)</code> 函数类似 <code>printf(...)</code> 函数，转义码基本相同
</p>
</div>
</div>

<div id="outline-container-org0bab3e6" class="outline-3">
<h3 id="org0bab3e6">匹配模式</h3>
<div class="outline-text-3" id="text-org0bab3e6">
<p>
单个字符与其自身匹配 (除 <code>^$()%*+-?</code> 外)
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字符类</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>.</code></td>
<td class="org-left">与任何字符匹配</td>
</tr>

<tr>
<td class="org-left"><code>%a</code></td>
<td class="org-left">字母</td>
</tr>

<tr>
<td class="org-left"><code>%c</code></td>
<td class="org-left">控制符</td>
</tr>

<tr>
<td class="org-left"><code>%d</code></td>
<td class="org-left">数字</td>
</tr>

<tr>
<td class="org-left"><code>%l</code></td>
<td class="org-left">小写字母</td>
</tr>

<tr>
<td class="org-left"><code>%p</code></td>
<td class="org-left">标点 punctuation</td>
</tr>

<tr>
<td class="org-left"><code>%s</code></td>
<td class="org-left">空白字符</td>
</tr>

<tr>
<td class="org-left"><code>%u</code></td>
<td class="org-left">大写字母</td>
</tr>

<tr>
<td class="org-left"><code>%w</code></td>
<td class="org-left">字母/数字</td>
</tr>

<tr>
<td class="org-left"><code>%x</code></td>
<td class="org-left">十六进制</td>
</tr>

<tr>
<td class="org-left"><code>%z</code></td>
<td class="org-left">表零字符</td>
</tr>

<tr>
<td class="org-left"><code>%x</code></td>
<td class="org-left">转义</td>
</tr>

<tr>
<td class="org-left"><code>[]</code></td>
<td class="org-left">字符集</td>
</tr>

<tr>
<td class="org-left"><code>[^]</code></td>
<td class="org-left">非字符集</td>
</tr>
</tbody>
</table>

<p>
大写 z 及之前的字母表示 <b><b>非</b></b>
</p>

<p>
特殊字符
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">字符</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>*</code></td>
<td class="org-left">零或多个，贪婪匹配</td>
</tr>

<tr>
<td class="org-left"><code>+</code></td>
<td class="org-left">一或多个</td>
</tr>

<tr>
<td class="org-left"><code>-</code></td>
<td class="org-left">零或多个，最短匹配</td>
</tr>

<tr>
<td class="org-left"><code>?</code></td>
<td class="org-left">零或一个</td>
</tr>

<tr>
<td class="org-left"><code>%n</code></td>
<td class="org-left">n = 1, 2, &#x2026;, 9 表示第几个匹配</td>
</tr>

<tr>
<td class="org-left"><code>%bxy</code></td>
<td class="org-left">x, y 为字符，例如 %b() 表示括号平衡的表达式</td>
</tr>

<tr>
<td class="org-left"><code>%f[set]</code></td>
<td class="org-left">边境模式，匹配位于 set 内某个字符之前的空串</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-ID-797f8520-7bfd-42d3-81e8-600c8f05a2df" class="outline-2">
<h2 id="ID-797f8520-7bfd-42d3-81e8-600c8f05a2df">Lua 数组</h2>
<div class="outline-text-2" id="text-ID-797f8520-7bfd-42d3-81e8-600c8f05a2df">
<p>
<b><b>相同数据类型按一定顺序排列的集合</b></b>
</p>
</div>

<div id="outline-container-orge6627a2" class="outline-3">
<h3 id="orge6627a2">一维数组</h3>
<div class="outline-text-3" id="text-orge6627a2">
<div class="org-src-container">
<pre class="src src-lua">array = { "Lua", "Language" }

for i = 0, 2 do
  print(array[i])
end
</pre>
</div>

<p>
Lua 索引从 1 开始，但可以指定 0 开始
</p>
</div>
</div>
<div id="outline-container-org1f6371b" class="outline-3">
<h3 id="org1f6371b">多维数组</h3>
<div class="outline-text-3" id="text-org1f6371b">
<p>
多维数组即数组中包含数组或一维数组的索引键对应一个数组
</p>
</div>
</div>
</div>

<div id="outline-container-ID-36033706-44ec-40c9-9f1f-9e52517c7ca4" class="outline-2">
<h2 id="ID-36033706-44ec-40c9-9f1f-9e52517c7ca4">Lua 迭代器</h2>
<div class="outline-text-2" id="text-ID-36033706-44ec-40c9-9f1f-9e52517c7ca4">
<p>
迭代器 iterator 是一种对象，能够用来遍历标准模板库容器中的部分或全部元素，每个迭代对象代表容器中的确定的地址，Lua 的迭代器是一种支持指针的结构。
</p>
</div>

<div id="outline-container-orgdb9e30f" class="outline-3">
<h3 id="orgdb9e30f">泛型 for 迭代器</h3>
<div class="outline-text-3" id="text-orgdb9e30f">
<p>
泛型 for 在内部保存迭代函数、状态常量、控制变量
</p>
<div class="org-src-container">
<pre class="src src-lua">array = {"a", "b"}

for key, value in ipairs(array)
do
  print(key, value)
end
</pre>
</div>

<p>
<code>ipairs()</code> 是 Lua 默认提供的迭代函数， <code>pairs()</code> 会将 table 型转为一整个数组进行处理
</p>
</div>
</div>

<div id="outline-container-org39366ae" class="outline-3">
<h3 id="org39366ae">无状态的迭代器</h3>
<div class="outline-text-3" id="text-org39366ae">
<p>
指不保留任何状态的迭代器
</p>

<p>
每一次迭代，迭代函数都是用两个变量（状态常量和控制变量）的值作为参数被调用，一个无状态的迭代器只利用这两个值可以获取下一个元素，例如 <code>ipairs()</code> ，遍历数组的每一个元素，元素的索引需要是数值
</p>

<p>
🌰
</p>

<div class="org-src-container">
<pre class="src src-lua">function square(iteratorMaxCount, currentNumber)
  if currentNumber &lt; iteratorMaxCount
  then
    currentNumber = currentNumber + 1
  return currentNumber, currentNumber ^ 2
  end
end

for i, n in square, 3, 0
do
  print(i, n)
end
</pre>
</div>

<p>
ipairs 实现：
</p>

<div class="org-src-container">
<pre class="src src-lua">function iter(a, i)
  i = i + 1
  local v = a[i]
  if v then
    return i, v
  end
end

function ipairs(a)
  return iter, a, 0
end
</pre>
</div>

<p>
当 Lua 调用 ipairs(a) 开始循环时，他获取三个值：迭代函数 iter、状态常量 a、控制变量初始值 0；然后 Lua 调用 iter(a, 0) 返回 1, a[1]（除非 a[1]=nil）；第二次迭代调用 iter(a,1) 返回 2, a[2]…… 直到遇到第一个 nil 元素。
</p>
</div>
</div>

<div id="outline-container-orgf40e2ad" class="outline-3">
<h3 id="orgf40e2ad">多状态的迭代器</h3>
<div class="outline-text-3" id="text-orgf40e2ad">
<p>
保存多个状态信息的迭代器，最简单方式是闭包，或者将所有的状态信息封装到 表 table 内，将 table 作为迭代器的状态常量
</p>

<p>
🌰
</p>

<div class="org-src-container">
<pre class="src src-lua">array = {"a", "b"}

function elementIterator(collection)
  local index = 0
  local count = #collection
  return function()
    if index &lt;= count
    then
      return collection[index]
    end
  end
end

for element in elementIterator(array)
do
  print(element)
end
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-ID-66bd9f20-0480-4713-8800-fad492574a46" class="outline-2">
<h2 id="ID-66bd9f20-0480-4713-8800-fad492574a46">Lua 表 table</h2>
<div class="outline-text-2" id="text-ID-66bd9f20-0480-4713-8800-fad492574a46">
<p>
table 是关联型数组，可以使用任意类型的值（除 nil）作为数组的索引，同时 Lua 通过 table 来解决模块 (module), 包 (package) 和对象 (Object)的
</p>

<p>
通过 <code>{}</code> 来构造一个 table
</p>

<div class="org-src-container">
<pre class="src src-lua">-- 初始化一个 table
mytable = {}

-- 指定某个索引对应的值
mytable[1] = "Lua"

-- 移除引用
mytable = nil
-- lua 的 gc 会释放内存，引用计数
</pre>
</div>
</div>

<div id="outline-container-org9fa9458" class="outline-3">
<h3 id="org9fa9458">常用方法</h3>
<div class="outline-text-3" id="text-org9fa9458">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">table.concat(table[, sep[, start[, end]]])</td>
<td class="org-left">concatenate，列出参数中指定的 table 的数组部分指定位置的所有元素，以指定的分隔符隔开</td>
</tr>

<tr>
<td class="org-left">table.insert(table, [pos, ] value)</td>
<td class="org-left">在数组的指定位置插入值为 value 的元素，默认末尾</td>
</tr>

<tr>
<td class="org-left">table.maxn(table)</td>
<td class="org-left">指定 table 中所有正数 key 值中最大的 key 值，lua 5.1 之前存在</td>
</tr>

<tr>
<td class="org-left">table.remove(table[, pos])</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">table.sort(table[, comp])</td>
<td class="org-left">对 table 进行排序</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-lua">function table_maxn(t)
  local mn = nil
  for k, v in pairs(t) do
    if mn == nil then
      mn = v
    end
    if mn &lt; v then
      mn = v
    end
  end
  return mn
end

tbl = {[1] = 2, [2] = 6, [3] = 34, [26] = 5}

print("tbl 最大值 ", table_maxn(tbl))
print("tbl 长度   ", #tbl)

-- tbl 最大值  34
-- tbl 长度    3
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-ID-e0a477d7-479c-4aa4-9d00-f7f2b9407be3" class="outline-2">
<h2 id="ID-e0a477d7-479c-4aa4-9d00-f7f2b9407be3">Lua 模块与包</h2>
<div class="outline-text-2" id="text-ID-e0a477d7-479c-4aa4-9d00-f7f2b9407be3">
<p>
Lua 的模块是由变量、函数等已知元素组成的 table
</p>
</div>

<div id="outline-container-org56788ae" class="outline-3">
<h3 id="org56788ae">require 函数</h3>
<div class="outline-text-3" id="text-org56788ae">
<div class="org-src-container">
<pre class="src src-lua">require("module")

require "module"
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb54ddc6" class="outline-3">
<h3 id="orgb54ddc6">加载机制</h3>
<div class="outline-text-3" id="text-orgb54ddc6">
<p>
require 用于搜索 Lua 文件的路径是存放在全局变量 package.path 中，当 Lua 启动后，会以环境变量 LUA<sub>PATH</sub> 的值来初始这个环境变量。如果没有找到该环境变量，则使用一个编译时定义的默认路径来初始化
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">LUA_PATH</span>
<span style="color: #006FE0;">export</span> <span style="color: #BA36A5;">LUA_PATH</span>=<span style="color: #008000;">"~/lua/?.lua;;"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc40a861" class="outline-3">
<h3 id="orgc40a861">C 包</h3>
<div class="outline-text-3" id="text-orgc40a861">
<p>
C 包在使用以前必须首先加载并连接，在大多数系统中最容易的实现方式是通过动态连接库机制
</p>

<p>
Lua 在一个叫 loadlib 的函数内提供了所有的动态连接的功能。这个函数有两个参数：库的绝对路径和初始化函数
</p>

<div class="org-src-container">
<pre class="src src-lua">local path = "/usr/local/lua/lib/libluasocket.so"
local f = loadlib(path, "luaopen_socket")
</pre>
</div>

<p>
loadlib 函数加载指定的库并且连接到 Lua，然而它并不调用初始化函数，返回初始化函数作为 Lua 的函数
</p>

<div class="org-src-container">
<pre class="src src-lua">local path = "/usr/local/lua/lib/libluasocket.so"
local f = assert(loadlib(path, "luaopen_socket"))
f()
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-ID-83e40e27-ad20-4167-9486-d244c010cfc4" class="outline-2">
<h2 id="ID-83e40e27-ad20-4167-9486-d244c010cfc4">Lua 元表 Metatable</h2>
<div class="outline-text-2" id="text-ID-83e40e27-ad20-4167-9486-d244c010cfc4">
<p>
允许改变 table 的行为，每个行为关联了对应的元方法
</p>

<p>
“重载”，例如 Lua 试图对两个表相加时，先检查两者之一是否有元表，之后检查是否有一个叫 <code>__add</code> 的字段，若找到，则调用对应的值。
</p>

<p>
相关函数：
</p>
<ul class="org-ul">
<li><code>setmetatable(table, metatable)</code> 对指定表设置元表，如果元表 <code>metatable</code> 中存在 <code>__metatable</code> 键值，此函数会失败</li>
<li><code>getmetatable(table)</code> 返回 table 的元表</li>
</ul>
</div>

<div id="outline-container-orgc5533f9" class="outline-3">
<h3 id="orgc5533f9"><code>__index</code> 元方法</h3>
<div class="outline-text-3" id="text-orgc5533f9">
<p>
定义了表在索引失败的情况下该怎么办
</p>

<p>
元表最常用的键，当通过键来访问 table 的时候，如果这个键没有值，那么 Lua 就会寻找该 table 的元表中的 <code>__index</code> 键，如果 <code>__index</code> 包含一个表格，Lua 会在表格中查找相应的键
</p>

<p>
如果 <code>__index</code> 包含一个函数的话，Lua 就会调用那个函数，table 和键会作为参数传递给函数
</p>

<p>
<code>__index</code> 元方法查看表中元素是否存在，如果不存在，返回结果为 <code>nil~；如果存在则由 ~__index</code> 返回结果
</p>

<p>
🌰
</p>
<div class="org-src-container">
<pre class="src src-lua">mytable = setmetatable({key1 = "value1"}, {
  __index = function(mytable, key)
    if key == "key2" then
      return "metatablevalue"
    else
      return nil
    end
  end
})

print(mytable.key1, mytable.key2)

--[[
  mytable 的 key2 实际并不存在
  但 mytable 存在元表
  如果元表定义了 __index
  就会调用这个 __index 方法
  若 __index 为 nil，即未定义
  返回 nil
  若 __index 是一个 table
  则在元表的 table 查找该索引
  若 __index 是一个 函数
  则调用该函数并返回函数结果

  可以把元表理解一个 table 的操作指南
]]

-- value1 metatablevalue

mytable = setmetatable({key = "value1"}, {__index = {key2 = "metatablevalue"}})
</pre>
</div>
</div>
</div>

<div id="outline-container-org4e38d92" class="outline-3">
<h3 id="org4e38d92"><code>__newindex</code> 元方法</h3>
<div class="outline-text-3" id="text-org4e38d92">
<p>
<code>__newindex</code> 用来对表更新，当给 table 一个缺少的索引赋值，解释器就会查找 <code>__newindex</code> 元方法：如果存在就调用这个函数而不进行赋值操作
</p>

<p>
🌰
</p>
<div class="org-src-container">
<pre class="src src-lua">mymetatable = {}
mytable = setmetable({key1 = "value1"}, {__newindex = mymetatable})

print(mytable.key1)

mytable.newkey = "newvalue"
print(mytable.newkey, mymetable.newkey)

mytable.key1 = "value11"
print(mytable.key1, mymetatable.key1)

-- value
-- nil newvalue
-- value11 nil
</pre>
</div>

<p>
🌰
</p>
<div class="org-src-container">
<pre class="src src-lua">mytable = setmetable({key1 = "value1"}, {
  __newindex = function(mytable, key, value)
    rawset(mytable, key, "\""..value.."\"")
  end
})

mytable.key1 = "newvalue"
mytable.key2 = 4

print(mytable.key1, mytable.key2)

-- newvalue "4"
</pre>
</div>
</div>
</div>

<div id="outline-container-org83a4f92" class="outline-3">
<h3 id="org83a4f92"><code>__call</code> 元方法</h3>
<div class="outline-text-3" id="text-org83a4f92">
<p>
在 Lua 调用 table 的一个值时调用
</p>
</div>
</div>

<div id="outline-container-org45c74dc" class="outline-3">
<h3 id="org45c74dc"><code>__string</code> 元方法</h3>
<div class="outline-text-3" id="text-org45c74dc">
<p>
修改 table 的输出行为
</p>
</div>
</div>

<div id="outline-container-org28946d5" class="outline-3">
<h3 id="org28946d5">其他元方法</h3>
<div class="outline-text-3" id="text-org28946d5">
<div class="org-src-container">
<pre class="src src-lua">__add    +
__sub    -
__mul    *
__div    /
__mod    %
__unm    -
__concat ..
__eq     ==
__lt     &lt;
__le     &lt;=
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-ID-1ef86fa1-bec0-428b-b1de-02a53a21fa8e" class="outline-2">
<h2 id="ID-1ef86fa1-bec0-428b-b1de-02a53a21fa8e">Lua 协同程序 coroutine</h2>
<div class="outline-text-2" id="text-ID-1ef86fa1-bec0-428b-b1de-02a53a21fa8e">
<p>
Lua 协同程序 (coroutine) 与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西
</p>
</div>

<div id="outline-container-orga0ab555" class="outline-3">
<h3 id="orga0ab555">线程和协同程序区别</h3>
<div class="outline-text-3" id="text-orga0ab555">
<p>
线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行；在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起
</p>

<p>
协同程序有点类似同步的多线程
</p>
</div>
</div>

<div id="outline-container-org0673e3e" class="outline-3">
<h3 id="org0673e3e">基本方法</h3>
<div class="outline-text-3" id="text-org0673e3e">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法</th>
<th scope="col" class="org-left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">coroutine.create()</td>
<td class="org-left">创建并返回 coroutine，参数是一个函数</td>
</tr>

<tr>
<td class="org-left">coroutine.resume()</td>
<td class="org-left">启动/继续 coroutine</td>
</tr>

<tr>
<td class="org-left">coroutine.yield()</td>
<td class="org-left">挂起 coroutine</td>
</tr>

<tr>
<td class="org-left">coroutine.status()</td>
<td class="org-left">查看 coroutine 状态，包含 dead, suspended, running</td>
</tr>

<tr>
<td class="org-left">coroutine.wrap()</td>
<td class="org-left">创建 coroutine，调用时进入 coroutine</td>
</tr>

<tr>
<td class="org-left">coroutine.running()</td>
<td class="org-left">返回正在运行的 coroutine</td>
</tr>
</tbody>
</table>

<p>
resume 和 create 配合使用时就唤醒函数调用
</p>

<p>
🌰 - 生产者-消费者问题
</p>
<div class="org-src-container">
<pre class="src src-lua">local newProductor

function productor()
  local i = 0
  while true do
    i = i + 1
    send(i)
  end
end

fuction consumer()
  while true do
    local i = receive()
    print(i)
  end
end

function receive()
  local status, value = coroutine.resume(newProductor)
  return value
end

function send(x)
  coroutine.yield(x)
end

newProductor = coroutine.create(productor)
consumer()
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-ID-9f98a4a7-80be-4291-82ea-f383031c724b" class="outline-2">
<h2 id="ID-9f98a4a7-80be-4291-82ea-f383031c724b">Lua I/O</h2>
<div class="outline-text-2" id="text-ID-9f98a4a7-80be-4291-82ea-f383031c724b">
<ul class="org-ul">
<li>简单模式：拥有一个当前输入文件和当前输出文件，并且提供对这些文件的相关操作</li>
<li>完全模式：使用外部的文件句柄来实现，以一种面向对象的形式，将所有的文件操作定义为文件句柄的方法</li>
</ul>

<div class="org-src-container">
<pre class="src src-lua">file = io.open(filename[, mode])
</pre>
</div>

<p>
mode:
</p>
<ul class="org-ul">
<li>r  只读，文件必须存在</li>
<li>w  只写</li>
<li>a  附加</li>
<li>r+ 可读写，文件必须存在</li>
<li>w+ 可读写</li>
<li>a+ 可读写</li>
<li>b  二进制</li>
<li>+  可读写</li>
</ul>
</div>


<div id="outline-container-org20e3043" class="outline-3">
<h3 id="org20e3043">简单模式</h3>
<div class="outline-text-3" id="text-org20e3043">
<p>
🌰
</p>
<div class="org-src-container">
<pre class="src src-lua">-- 以只读方式打开文件
file = io.open("test.lua", "r")

-- 设置默认输入文件为 test.lua
io.input(file)

-- 输出文件第一行
print(io.read())

-- 关闭打开的文件
io.close(file)

-- 以附加的方式打开只写文件
file = io.open("test.lua", "a")

-- 设置默认输出文件为 test.lua
io.output(file)

-- 在文件最后一行添加 Lua 注释
io.write("--  test.lua 文件末尾注释")

-- 关闭打开的文件
io.close(file)
</pre>
</div>

<p>
read 函数的参数
</p>
<ul class="org-ul">
<li><code>"*n"</code>  读取一个数字并返回</li>
<li><code>"*a"</code>  从当前位置读取整个文件</li>
<li><code>"*l</code>   读取下一行</li>
<li>number  返回一个指定字符个数的字符串，或在 EOF 时返回 nil</li>
</ul>

<p>
io.tmpfile() 返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除
</p>

<p>
io.type(file) 检测 obj 是否是一个可用的文件句柄
</p>

<p>
io.flush() 向文件写入缓冲中的所有数据
</p>

<p>
io.lines(optional file name) 返回一个迭代函数，每次调用获取文件中一行内容
</p>
</div>
</div>

<div id="outline-container-org3b53a35" class="outline-3">
<h3 id="org3b53a35">完全模式</h3>
<div class="outline-text-3" id="text-org3b53a35">
<p>
同一时间处理多个文件，使用 <a href="function_name">function_name</a> 来代替 io.function<sub>name</sub> 方法
</p>

<div class="org-src-container">
<pre class="src src-lua">-- 以只读方式打开文件
file = io.open("test.lua", "r")

-- 输出文件第一行
print(file:read())

-- 关闭打开的文件
file:close()

-- 以附加的方式打开只写文件
file = io.open("test.lua", "a")

-- 在文件最后一行添加 Lua 注释
file:write("--test")

-- 关闭打开的文件
file:close()
</pre>
</div>

<p>
方法：
</p>

<p>
<a href="seek">seek</a>(optional whence, optional offset) 设置和获取当前文件位置，成功则返回最终的文件位置，失败则返回 nil 加错误信息
</p>

<p>
whence =
</p>
<ul class="org-ul">
<li>&ldquo;set&rdquo; 从文件头开始</li>
<li>&ldquo;cur&rdquo; 从当前位置开始</li>
<li>&ldquo;end&rdquo; 从文件尾开始</li>
</ul>

<p>
offset 默认为 0
</p>

<p>
<a href="flush()">flush()</a>
</p>

<p>
<a href="lines">lines</a>(optional file name)
</p>
</div>
</div>
</div>


<div id="outline-container-ID-56dfdc61-5be3-40b1-8825-c2523bb2f006" class="outline-2">
<h2 id="ID-56dfdc61-5be3-40b1-8825-c2523bb2f006">Lua 错误处理</h2>
<div class="outline-text-2" id="text-ID-56dfdc61-5be3-40b1-8825-c2523bb2f006">
</div>
<div id="outline-container-org264b71f" class="outline-3">
<h3 id="org264b71f">assert()</h3>
<div class="outline-text-3" id="text-org264b71f">
<p>
assert(argument, message)
</p>

<p>
assert 首先检查第一个参数，若没问题，assert 不做任何事情；否则，assert 以第二个参数作为错误信息抛出
</p>
</div>
</div>

<div id="outline-container-orgef21b04" class="outline-3">
<h3 id="orgef21b04">error()</h3>
<div class="outline-text-3" id="text-orgef21b04">
<p>
error(message[, level])
</p>

<p>
终止正在执行的函数，并返回 message 的内容作为错误信息
</p>

<p>
level 参数指示获得错误的位置
</p>
<ul class="org-ul">
<li>1 默认，为调用 error 的位置，文件 + 行号</li>
<li>2 指出那个调用 error 的函数</li>
<li>0 不添加错误位置信息</li>
</ul>
</div>
</div>

<div id="outline-container-orgad5764f" class="outline-3">
<h3 id="orgad5764f">pcall, xpcall</h3>
<div class="outline-text-3" id="text-orgad5764f">
<p>
pcall 接收一个函数和要传递给后者的参数，并执行，返回值 true / false, errorinfo
</p>

<div class="org-src-container">
<pre class="src src-lua">if pcall(function_name) then

else

end
</pre>
</div>

<p>
xpcall 相比与 pcall 接收第二个参数：一个错误处理函数，当错误发生时，Lua 会在调用栈展开 (unwind) 前调用错误处理函数
</p>
</div>
</div>

<div id="outline-container-orga8f9241" class="outline-3">
<h3 id="orga8f9241">debug 库</h3>
</div>
</div>


<div id="outline-container-ID-edbcb6f6-313a-4e7a-845d-e70a8184c73c" class="outline-2">
<h2 id="ID-edbcb6f6-313a-4e7a-845d-e70a8184c73c">Lua 垃圾回收</h2>
<div class="outline-text-2" id="text-ID-edbcb6f6-313a-4e7a-845d-e70a8184c73c">
<p>
Lua 运行了一个垃圾收集器来收集所有死对象，实现了一个增量标记-扫描收集器。使用两个标记来控制垃圾收集循环，单位都是百分数
</p>

<ul class="org-ul">
<li>垃圾收集器间歇率    200 表示 2 倍内存时开始新的循环</li>
<li>垃圾收集器步进倍率  200 表示以内存分配的 2 倍速工作</li>
</ul>

<p>
collectgarbage([opt [, arg]])
</p>

<p>
opt =
</p>
<ul class="org-ul">
<li>&ldquo;collect&rdquo;  做一次完整的垃圾循环</li>
<li>&ldquo;count&rdquo;    以 K 字节数为单位返回 Lua 使用的总内存数</li>
<li>&ldquo;restart&rdquo;  重启垃圾收集器的自动运行</li>
<li>&ldquo;setpause&rdquo; 将 arg 设为收集器的间歇率，返回间歇率的前值</li>
<li>&ldquo;step&rdquo;     单步运行垃圾收集器</li>
<li>&ldquo;stop&rdquo;     停止垃圾收集器的运行</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<a href="https://beian.miit.gov.cn" target="_blank">湘ICP证019014083号</a>
</div>
</body>
</html>
